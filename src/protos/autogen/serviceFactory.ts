/* Autogenerated File! Do Not Edit */

import { ClientOptions } from "../../client";
import { CustomerOptions } from "../../types";
import { Service } from "../../service";
import { resources, services, protobuf, longrunning } from "../index";
import {
  BaseMutationHookArgs,
  BaseServiceHookArgs,
  HookedCancellation,
  HookedResolution,
  Hooks,
} from "../../hooks";

export default class ServiceFactory extends Service {
  constructor(
    clientOptions: ClientOptions,
    customerOptions: CustomerOptions,
    hooks?: Hooks
  ) {
    super(clientOptions, customerOptions, hooks ?? {});
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AccountBudgetProposalService
   */
  public get accountBudgetProposals() {
    const service = this.loadService<services.AccountBudgetProposalService>(
      "AccountBudgetProposalServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateAccountBudgetProposalRequest, "validate_only">
    >;
    return {
      /**
       * @description create resources of type resources.IAccountBudgetProposal
       * @returns services.MutateAccountBudgetProposalResponse
       */
      create: async (
        accountBudgetProposals: (
          | resources.IAccountBudgetProposal
          | resources.AccountBudgetProposal
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAccountBudgetProposalResponse> => {
        const ops = this.buildOperations<
          services.AccountBudgetProposalOperation,
          resources.IAccountBudgetProposal
        >("create", accountBudgetProposals);
        const request = this.buildRequest<
          services.AccountBudgetProposalOperation,
          services.IMutateAccountBudgetProposalRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AccountBudgetProposalService.mutateAccountBudgetProposal",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAccountBudgetProposal(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAccountBudgetProposalResponse
       */
      remove: async (
        accountBudgetProposals: string[],
        options?: MutateOptions
      ): Promise<services.MutateAccountBudgetProposalResponse> => {
        const ops = this.buildOperations<
          services.AccountBudgetProposalOperation,
          string
        >("remove", accountBudgetProposals);
        const request = this.buildRequest<
          services.AccountBudgetProposalOperation,
          services.IMutateAccountBudgetProposalRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AccountBudgetProposalService.mutateAccountBudgetProposal",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAccountBudgetProposal(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AccountLinkService
   */
  public get accountLinks() {
    const service = this.loadService<services.AccountLinkService>(
      "AccountLinkServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAccountLinkRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AccountLinkService#createaccountlink
       */
      createAccountLink: async (
        request: services.CreateAccountLinkRequest
      ): Promise<services.CreateAccountLinkResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "AccountLinkService.CreateAccountLink",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.createAccountLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAccountLink
       * @returns services.MutateAccountLinkResponse
       */
      update: async (
        accountLinks: (resources.IAccountLink | resources.AccountLink)[],
        options?: MutateOptions
      ): Promise<services.MutateAccountLinkResponse> => {
        const ops = this.buildOperations<
          services.AccountLinkOperation,
          resources.IAccountLink
        >(
          "update",
          accountLinks,
          // @ts-expect-error Static class type here is fine
          resources.AccountLink
        );
        const request = this.buildRequest<
          services.AccountLinkOperation,
          services.IMutateAccountLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AccountLinkService.mutateAccountLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAccountLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAccountLinkResponse
       */
      remove: async (
        accountLinks: string[],
        options?: MutateOptions
      ): Promise<services.MutateAccountLinkResponse> => {
        const ops = this.buildOperations<services.AccountLinkOperation, string>(
          "remove",
          accountLinks
        );
        const request = this.buildRequest<
          services.AccountLinkOperation,
          services.IMutateAccountLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AccountLinkService.mutateAccountLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAccountLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupAdLabelService
   */
  public get adGroupAdLabels() {
    const service = this.loadService<services.AdGroupAdLabelService>(
      "AdGroupAdLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupAdLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupAdLabel
       * @returns services.MutateAdGroupAdLabelsResponse
       */
      create: async (
        adGroupAdLabels: (
          | resources.IAdGroupAdLabel
          | resources.AdGroupAdLabel
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAdLabelOperation,
          resources.IAdGroupAdLabel
        >("create", adGroupAdLabels);
        const request = this.buildRequest<
          services.AdGroupAdLabelOperation,
          services.IMutateAdGroupAdLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdLabelService.mutateAdGroupAdLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAdLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupAdLabelsResponse
       */
      remove: async (
        adGroupAdLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAdLabelOperation,
          string
        >("remove", adGroupAdLabels);
        const request = this.buildRequest<
          services.AdGroupAdLabelOperation,
          services.IMutateAdGroupAdLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdLabelService.mutateAdGroupAdLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAdLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupAdService
   */
  public get adGroupAds() {
    const service = this.loadService<services.AdGroupAdService>(
      "AdGroupAdServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupAdsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupAd
       * @returns services.MutateAdGroupAdsResponse
       */
      create: async (
        adGroupAds: (resources.IAdGroupAd | resources.AdGroupAd)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAdOperation,
          resources.IAdGroupAd
        >("create", adGroupAds);
        const request = this.buildRequest<
          services.AdGroupAdOperation,
          services.IMutateAdGroupAdsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdService.mutateAdGroupAds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupAd
       * @returns services.MutateAdGroupAdsResponse
       */
      update: async (
        adGroupAds: (resources.IAdGroupAd | resources.AdGroupAd)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAdOperation,
          resources.IAdGroupAd
        >(
          "update",
          adGroupAds,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupAd
        );
        const request = this.buildRequest<
          services.AdGroupAdOperation,
          services.IMutateAdGroupAdsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdService.mutateAdGroupAds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupAdsResponse
       */
      remove: async (
        adGroupAds: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdsResponse> => {
        const ops = this.buildOperations<services.AdGroupAdOperation, string>(
          "remove",
          adGroupAds
        );
        const request = this.buildRequest<
          services.AdGroupAdOperation,
          services.IMutateAdGroupAdsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdService.mutateAdGroupAds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupAssetService
   */
  public get adGroupAssets() {
    const service = this.loadService<services.AdGroupAssetService>(
      "AdGroupAssetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupAssetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupAsset
       * @returns services.MutateAdGroupAssetsResponse
       */
      create: async (
        adGroupAssets: (resources.IAdGroupAsset | resources.AdGroupAsset)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAssetsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAssetOperation,
          resources.IAdGroupAsset
        >("create", adGroupAssets);
        const request = this.buildRequest<
          services.AdGroupAssetOperation,
          services.IMutateAdGroupAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAssetService.mutateAdGroupAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupAsset
       * @returns services.MutateAdGroupAssetsResponse
       */
      update: async (
        adGroupAssets: (resources.IAdGroupAsset | resources.AdGroupAsset)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAssetsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAssetOperation,
          resources.IAdGroupAsset
        >(
          "update",
          adGroupAssets,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupAsset
        );
        const request = this.buildRequest<
          services.AdGroupAssetOperation,
          services.IMutateAdGroupAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAssetService.mutateAdGroupAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupAssetsResponse
       */
      remove: async (
        adGroupAssets: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAssetsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAssetOperation,
          string
        >("remove", adGroupAssets);
        const request = this.buildRequest<
          services.AdGroupAssetOperation,
          services.IMutateAdGroupAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAssetService.mutateAdGroupAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupAssetSetService
   */
  public get adGroupAssetSets() {
    const service = this.loadService<services.AdGroupAssetSetService>(
      "AdGroupAssetSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupAssetSetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupAssetSet
       * @returns services.MutateAdGroupAssetSetsResponse
       */
      create: async (
        adGroupAssetSets: (
          | resources.IAdGroupAssetSet
          | resources.AdGroupAssetSet
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAssetSetsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAssetSetOperation,
          resources.IAdGroupAssetSet
        >("create", adGroupAssetSets);
        const request = this.buildRequest<
          services.AdGroupAssetSetOperation,
          services.IMutateAdGroupAssetSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAssetSetService.mutateAdGroupAssetSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAssetSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupAssetSetsResponse
       */
      remove: async (
        adGroupAssetSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAssetSetsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAssetSetOperation,
          string
        >("remove", adGroupAssetSets);
        const request = this.buildRequest<
          services.AdGroupAssetSetOperation,
          services.IMutateAdGroupAssetSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAssetSetService.mutateAdGroupAssetSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAssetSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupBidModifierService
   */
  public get adGroupBidModifiers() {
    const service = this.loadService<services.AdGroupBidModifierService>(
      "AdGroupBidModifierServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupBidModifiersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupBidModifier
       * @returns services.MutateAdGroupBidModifiersResponse
       */
      create: async (
        adGroupBidModifiers: (
          | resources.IAdGroupBidModifier
          | resources.AdGroupBidModifier
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupBidModifierOperation,
          resources.IAdGroupBidModifier
        >("create", adGroupBidModifiers);
        const request = this.buildRequest<
          services.AdGroupBidModifierOperation,
          services.IMutateAdGroupBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupBidModifier
       * @returns services.MutateAdGroupBidModifiersResponse
       */
      update: async (
        adGroupBidModifiers: (
          | resources.IAdGroupBidModifier
          | resources.AdGroupBidModifier
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupBidModifierOperation,
          resources.IAdGroupBidModifier
        >(
          "update",
          adGroupBidModifiers,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupBidModifier
        );
        const request = this.buildRequest<
          services.AdGroupBidModifierOperation,
          services.IMutateAdGroupBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupBidModifiersResponse
       */
      remove: async (
        adGroupBidModifiers: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupBidModifierOperation,
          string
        >("remove", adGroupBidModifiers);
        const request = this.buildRequest<
          services.AdGroupBidModifierOperation,
          services.IMutateAdGroupBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupCriterionCustomizerService
   */
  public get adGroupCriterionCustomizers() {
    const service =
      this.loadService<services.AdGroupCriterionCustomizerService>(
        "AdGroupCriterionCustomizerServiceClient"
      );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupCriterionCustomizersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupCriterionCustomizer
       * @returns services.MutateAdGroupCriterionCustomizersResponse
       */
      create: async (
        adGroupCriterionCustomizers: (
          | resources.IAdGroupCriterionCustomizer
          | resources.AdGroupCriterionCustomizer
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriterionCustomizersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionCustomizerOperation,
          resources.IAdGroupCriterionCustomizer
        >("create", adGroupCriterionCustomizers);
        const request = this.buildRequest<
          services.AdGroupCriterionCustomizerOperation,
          services.IMutateAdGroupCriterionCustomizersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AdGroupCriterionCustomizerService.mutateAdGroupCriterionCustomizers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriterionCustomizers(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupCriterionCustomizersResponse
       */
      remove: async (
        adGroupCriterionCustomizers: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriterionCustomizersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionCustomizerOperation,
          string
        >("remove", adGroupCriterionCustomizers);
        const request = this.buildRequest<
          services.AdGroupCriterionCustomizerOperation,
          services.IMutateAdGroupCriterionCustomizersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AdGroupCriterionCustomizerService.mutateAdGroupCriterionCustomizers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriterionCustomizers(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupCriterionLabelService
   */
  public get adGroupCriterionLabels() {
    const service = this.loadService<services.AdGroupCriterionLabelService>(
      "AdGroupCriterionLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupCriterionLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupCriterionLabel
       * @returns services.MutateAdGroupCriterionLabelsResponse
       */
      create: async (
        adGroupCriterionLabels: (
          | resources.IAdGroupCriterionLabel
          | resources.AdGroupCriterionLabel
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriterionLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionLabelOperation,
          resources.IAdGroupCriterionLabel
        >("create", adGroupCriterionLabels);
        const request = this.buildRequest<
          services.AdGroupCriterionLabelOperation,
          services.IMutateAdGroupCriterionLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionLabelService.mutateAdGroupCriterionLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriterionLabels(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupCriterionLabelsResponse
       */
      remove: async (
        adGroupCriterionLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriterionLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionLabelOperation,
          string
        >("remove", adGroupCriterionLabels);
        const request = this.buildRequest<
          services.AdGroupCriterionLabelOperation,
          services.IMutateAdGroupCriterionLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionLabelService.mutateAdGroupCriterionLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriterionLabels(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupCriterionService
   */
  public get adGroupCriteria() {
    const service = this.loadService<services.AdGroupCriterionService>(
      "AdGroupCriterionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupCriteriaRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupCriterion
       * @returns services.MutateAdGroupCriteriaResponse
       */
      create: async (
        adGroupCriteria: (
          | resources.IAdGroupCriterion
          | resources.AdGroupCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriteriaResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionOperation,
          resources.IAdGroupCriterion
        >("create", adGroupCriteria);
        const request = this.buildRequest<
          services.AdGroupCriterionOperation,
          services.IMutateAdGroupCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionService.mutateAdGroupCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupCriterion
       * @returns services.MutateAdGroupCriteriaResponse
       */
      update: async (
        adGroupCriteria: (
          | resources.IAdGroupCriterion
          | resources.AdGroupCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriteriaResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionOperation,
          resources.IAdGroupCriterion
        >(
          "update",
          adGroupCriteria,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupCriterion
        );
        const request = this.buildRequest<
          services.AdGroupCriterionOperation,
          services.IMutateAdGroupCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionService.mutateAdGroupCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupCriteriaResponse
       */
      remove: async (
        adGroupCriteria: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriteriaResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionOperation,
          string
        >("remove", adGroupCriteria);
        const request = this.buildRequest<
          services.AdGroupCriterionOperation,
          services.IMutateAdGroupCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionService.mutateAdGroupCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupCustomizerService
   */
  public get adGroupCustomizers() {
    const service = this.loadService<services.AdGroupCustomizerService>(
      "AdGroupCustomizerServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupCustomizersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupCustomizer
       * @returns services.MutateAdGroupCustomizersResponse
       */
      create: async (
        adGroupCustomizers: (
          | resources.IAdGroupCustomizer
          | resources.AdGroupCustomizer
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCustomizersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCustomizerOperation,
          resources.IAdGroupCustomizer
        >("create", adGroupCustomizers);
        const request = this.buildRequest<
          services.AdGroupCustomizerOperation,
          services.IMutateAdGroupCustomizersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCustomizerService.mutateAdGroupCustomizers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCustomizers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupCustomizersResponse
       */
      remove: async (
        adGroupCustomizers: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCustomizersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCustomizerOperation,
          string
        >("remove", adGroupCustomizers);
        const request = this.buildRequest<
          services.AdGroupCustomizerOperation,
          services.IMutateAdGroupCustomizersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCustomizerService.mutateAdGroupCustomizers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCustomizers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupExtensionSettingService
   */
  public get adGroupExtensionSettings() {
    const service = this.loadService<services.AdGroupExtensionSettingService>(
      "AdGroupExtensionSettingServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupExtensionSettingsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupExtensionSetting
       * @returns services.MutateAdGroupExtensionSettingsResponse
       */
      create: async (
        adGroupExtensionSettings: (
          | resources.IAdGroupExtensionSetting
          | resources.AdGroupExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupExtensionSettingOperation,
          resources.IAdGroupExtensionSetting
        >("create", adGroupExtensionSettings);
        const request = this.buildRequest<
          services.AdGroupExtensionSettingOperation,
          services.IMutateAdGroupExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AdGroupExtensionSettingService.mutateAdGroupExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupExtensionSetting
       * @returns services.MutateAdGroupExtensionSettingsResponse
       */
      update: async (
        adGroupExtensionSettings: (
          | resources.IAdGroupExtensionSetting
          | resources.AdGroupExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupExtensionSettingOperation,
          resources.IAdGroupExtensionSetting
        >(
          "update",
          adGroupExtensionSettings,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupExtensionSetting
        );
        const request = this.buildRequest<
          services.AdGroupExtensionSettingOperation,
          services.IMutateAdGroupExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AdGroupExtensionSettingService.mutateAdGroupExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupExtensionSettingsResponse
       */
      remove: async (
        adGroupExtensionSettings: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupExtensionSettingOperation,
          string
        >("remove", adGroupExtensionSettings);
        const request = this.buildRequest<
          services.AdGroupExtensionSettingOperation,
          services.IMutateAdGroupExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AdGroupExtensionSettingService.mutateAdGroupExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupFeedService
   */
  public get adGroupFeeds() {
    const service = this.loadService<services.AdGroupFeedService>(
      "AdGroupFeedServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupFeedsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupFeed
       * @returns services.MutateAdGroupFeedsResponse
       */
      create: async (
        adGroupFeeds: (resources.IAdGroupFeed | resources.AdGroupFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupFeedsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupFeedOperation,
          resources.IAdGroupFeed
        >("create", adGroupFeeds);
        const request = this.buildRequest<
          services.AdGroupFeedOperation,
          services.IMutateAdGroupFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupFeedService.mutateAdGroupFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupFeed
       * @returns services.MutateAdGroupFeedsResponse
       */
      update: async (
        adGroupFeeds: (resources.IAdGroupFeed | resources.AdGroupFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupFeedsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupFeedOperation,
          resources.IAdGroupFeed
        >(
          "update",
          adGroupFeeds,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupFeed
        );
        const request = this.buildRequest<
          services.AdGroupFeedOperation,
          services.IMutateAdGroupFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupFeedService.mutateAdGroupFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupFeedsResponse
       */
      remove: async (
        adGroupFeeds: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupFeedsResponse> => {
        const ops = this.buildOperations<services.AdGroupFeedOperation, string>(
          "remove",
          adGroupFeeds
        );
        const request = this.buildRequest<
          services.AdGroupFeedOperation,
          services.IMutateAdGroupFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupFeedService.mutateAdGroupFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupLabelService
   */
  public get adGroupLabels() {
    const service = this.loadService<services.AdGroupLabelService>(
      "AdGroupLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroupLabel
       * @returns services.MutateAdGroupLabelsResponse
       */
      create: async (
        adGroupLabels: (resources.IAdGroupLabel | resources.AdGroupLabel)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupLabelOperation,
          resources.IAdGroupLabel
        >("create", adGroupLabels);
        const request = this.buildRequest<
          services.AdGroupLabelOperation,
          services.IMutateAdGroupLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupLabelService.mutateAdGroupLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupLabelsResponse
       */
      remove: async (
        adGroupLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupLabelOperation,
          string
        >("remove", adGroupLabels);
        const request = this.buildRequest<
          services.AdGroupLabelOperation,
          services.IMutateAdGroupLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupLabelService.mutateAdGroupLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdGroupService
   */
  public get adGroups() {
    const service = this.loadService<services.AdGroupService>(
      "AdGroupServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdGroup
       * @returns services.MutateAdGroupsResponse
       */
      create: async (
        adGroups: (resources.IAdGroup | resources.AdGroup)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupOperation,
          resources.IAdGroup
        >("create", adGroups);
        const request = this.buildRequest<
          services.AdGroupOperation,
          services.IMutateAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupService.mutateAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroup
       * @returns services.MutateAdGroupsResponse
       */
      update: async (
        adGroups: (resources.IAdGroup | resources.AdGroup)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupOperation,
          resources.IAdGroup
        >(
          "update",
          adGroups,
          // @ts-expect-error Static class type here is fine
          resources.AdGroup
        );
        const request = this.buildRequest<
          services.AdGroupOperation,
          services.IMutateAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupService.mutateAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupsResponse
       */
      remove: async (
        adGroups: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupsResponse> => {
        const ops = this.buildOperations<services.AdGroupOperation, string>(
          "remove",
          adGroups
        );
        const request = this.buildRequest<
          services.AdGroupOperation,
          services.IMutateAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupService.mutateAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdParameterService
   */
  public get adParameters() {
    const service = this.loadService<services.AdParameterService>(
      "AdParameterServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdParametersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAdParameter
       * @returns services.MutateAdParametersResponse
       */
      create: async (
        adParameters: (resources.IAdParameter | resources.AdParameter)[],
        options?: MutateOptions
      ): Promise<services.MutateAdParametersResponse> => {
        const ops = this.buildOperations<
          services.AdParameterOperation,
          resources.IAdParameter
        >("create", adParameters);
        const request = this.buildRequest<
          services.AdParameterOperation,
          services.IMutateAdParametersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdParameterService.mutateAdParameters",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdParameters(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdParameter
       * @returns services.MutateAdParametersResponse
       */
      update: async (
        adParameters: (resources.IAdParameter | resources.AdParameter)[],
        options?: MutateOptions
      ): Promise<services.MutateAdParametersResponse> => {
        const ops = this.buildOperations<
          services.AdParameterOperation,
          resources.IAdParameter
        >(
          "update",
          adParameters,
          // @ts-expect-error Static class type here is fine
          resources.AdParameter
        );
        const request = this.buildRequest<
          services.AdParameterOperation,
          services.IMutateAdParametersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdParameterService.mutateAdParameters",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdParameters(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdParametersResponse
       */
      remove: async (
        adParameters: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdParametersResponse> => {
        const ops = this.buildOperations<services.AdParameterOperation, string>(
          "remove",
          adParameters
        );
        const request = this.buildRequest<
          services.AdParameterOperation,
          services.IMutateAdParametersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdParameterService.mutateAdParameters",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdParameters(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdService
   */
  public get ads() {
    const service = this.loadService<services.AdService>("AdServiceClient");
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdsRequest,
        "partial_failure" | "response_content_type" | "validate_only"
      >
    >;
    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AdService#getad
       */
      getAd: async (request: services.GetAdRequest): Promise<resources.Ad> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "AdService.GetAd",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAd(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAd
       * @returns services.MutateAdsResponse
       */
      update: async (
        ads: (resources.IAd | resources.Ad)[],
        options?: MutateOptions
      ): Promise<services.MutateAdsResponse> => {
        const ops = this.buildOperations<services.AdOperation, resources.IAd>(
          "update",
          ads,
          // @ts-expect-error Static class type here is fine
          resources.Ad
        );
        const request = this.buildRequest<
          services.AdOperation,
          services.IMutateAdsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdService.mutateAds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetGroupAssetService
   */
  public get assetGroupAssets() {
    const service = this.loadService<services.AssetGroupAssetService>(
      "AssetGroupAssetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAssetGroupAssetsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAssetGroupAsset
       * @returns services.MutateAssetGroupAssetsResponse
       */
      create: async (
        assetGroupAssets: (
          | resources.IAssetGroupAsset
          | resources.AssetGroupAsset
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupAssetsResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupAssetOperation,
          resources.IAssetGroupAsset
        >("create", assetGroupAssets);
        const request = this.buildRequest<
          services.AssetGroupAssetOperation,
          services.IMutateAssetGroupAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetGroupAssetService.mutateAssetGroupAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroupAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAssetGroupAsset
       * @returns services.MutateAssetGroupAssetsResponse
       */
      update: async (
        assetGroupAssets: (
          | resources.IAssetGroupAsset
          | resources.AssetGroupAsset
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupAssetsResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupAssetOperation,
          resources.IAssetGroupAsset
        >(
          "update",
          assetGroupAssets,
          // @ts-expect-error Static class type here is fine
          resources.AssetGroupAsset
        );
        const request = this.buildRequest<
          services.AssetGroupAssetOperation,
          services.IMutateAssetGroupAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetGroupAssetService.mutateAssetGroupAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroupAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAssetGroupAssetsResponse
       */
      remove: async (
        assetGroupAssets: string[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupAssetsResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupAssetOperation,
          string
        >("remove", assetGroupAssets);
        const request = this.buildRequest<
          services.AssetGroupAssetOperation,
          services.IMutateAssetGroupAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetGroupAssetService.mutateAssetGroupAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroupAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetGroupListingGroupFilterService
   */
  public get assetGroupListingGroupFilters() {
    const service =
      this.loadService<services.AssetGroupListingGroupFilterService>(
        "AssetGroupListingGroupFilterServiceClient"
      );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAssetGroupListingGroupFiltersRequest,
        "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAssetGroupListingGroupFilter
       * @returns services.MutateAssetGroupListingGroupFiltersResponse
       */
      create: async (
        assetGroupListingGroupFilters: (
          | resources.IAssetGroupListingGroupFilter
          | resources.AssetGroupListingGroupFilter
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupListingGroupFiltersResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupListingGroupFilterOperation,
          resources.IAssetGroupListingGroupFilter
        >("create", assetGroupListingGroupFilters);
        const request = this.buildRequest<
          services.AssetGroupListingGroupFilterOperation,
          services.IMutateAssetGroupListingGroupFiltersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AssetGroupListingGroupFilterService.mutateAssetGroupListingGroupFilters",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroupListingGroupFilters(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAssetGroupListingGroupFilter
       * @returns services.MutateAssetGroupListingGroupFiltersResponse
       */
      update: async (
        assetGroupListingGroupFilters: (
          | resources.IAssetGroupListingGroupFilter
          | resources.AssetGroupListingGroupFilter
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupListingGroupFiltersResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupListingGroupFilterOperation,
          resources.IAssetGroupListingGroupFilter
        >(
          "update",
          assetGroupListingGroupFilters,
          // @ts-expect-error Static class type here is fine
          resources.AssetGroupListingGroupFilter
        );
        const request = this.buildRequest<
          services.AssetGroupListingGroupFilterOperation,
          services.IMutateAssetGroupListingGroupFiltersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AssetGroupListingGroupFilterService.mutateAssetGroupListingGroupFilters",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroupListingGroupFilters(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAssetGroupListingGroupFiltersResponse
       */
      remove: async (
        assetGroupListingGroupFilters: string[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupListingGroupFiltersResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupListingGroupFilterOperation,
          string
        >("remove", assetGroupListingGroupFilters);
        const request = this.buildRequest<
          services.AssetGroupListingGroupFilterOperation,
          services.IMutateAssetGroupListingGroupFiltersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AssetGroupListingGroupFilterService.mutateAssetGroupListingGroupFilters",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroupListingGroupFilters(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetGroupService
   */
  public get assetGroups() {
    const service = this.loadService<services.AssetGroupService>(
      "AssetGroupServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateAssetGroupsRequest, "validate_only">
    >;
    return {
      /**
       * @description create resources of type resources.IAssetGroup
       * @returns services.MutateAssetGroupsResponse
       */
      create: async (
        assetGroups: (resources.IAssetGroup | resources.AssetGroup)[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupsResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupOperation,
          resources.IAssetGroup
        >("create", assetGroups);
        const request = this.buildRequest<
          services.AssetGroupOperation,
          services.IMutateAssetGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetGroupService.mutateAssetGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAssetGroup
       * @returns services.MutateAssetGroupsResponse
       */
      update: async (
        assetGroups: (resources.IAssetGroup | resources.AssetGroup)[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupsResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupOperation,
          resources.IAssetGroup
        >(
          "update",
          assetGroups,
          // @ts-expect-error Static class type here is fine
          resources.AssetGroup
        );
        const request = this.buildRequest<
          services.AssetGroupOperation,
          services.IMutateAssetGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetGroupService.mutateAssetGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAssetGroupsResponse
       */
      remove: async (
        assetGroups: string[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupsResponse> => {
        const ops = this.buildOperations<services.AssetGroupOperation, string>(
          "remove",
          assetGroups
        );
        const request = this.buildRequest<
          services.AssetGroupOperation,
          services.IMutateAssetGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetGroupService.mutateAssetGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetGroupSignalService
   */
  public get assetGroupSignals() {
    const service = this.loadService<services.AssetGroupSignalService>(
      "AssetGroupSignalServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAssetGroupSignalsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAssetGroupSignal
       * @returns services.MutateAssetGroupSignalsResponse
       */
      create: async (
        assetGroupSignals: (
          | resources.IAssetGroupSignal
          | resources.AssetGroupSignal
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupSignalsResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupSignalOperation,
          resources.IAssetGroupSignal
        >("create", assetGroupSignals);
        const request = this.buildRequest<
          services.AssetGroupSignalOperation,
          services.IMutateAssetGroupSignalsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetGroupSignalService.mutateAssetGroupSignals",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroupSignals(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAssetGroupSignalsResponse
       */
      remove: async (
        assetGroupSignals: string[],
        options?: MutateOptions
      ): Promise<services.MutateAssetGroupSignalsResponse> => {
        const ops = this.buildOperations<
          services.AssetGroupSignalOperation,
          string
        >("remove", assetGroupSignals);
        const request = this.buildRequest<
          services.AssetGroupSignalOperation,
          services.IMutateAssetGroupSignalsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetGroupSignalService.mutateAssetGroupSignals",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetGroupSignals(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetService
   */
  public get assets() {
    const service =
      this.loadService<services.AssetService>("AssetServiceClient");
    type MutateOptions = Partial<
      Pick<
        services.IMutateAssetsRequest,
        "partial_failure" | "response_content_type" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAsset
       * @returns services.MutateAssetsResponse
       */
      create: async (
        assets: (resources.IAsset | resources.Asset)[],
        options?: MutateOptions
      ): Promise<services.MutateAssetsResponse> => {
        const ops = this.buildOperations<
          services.AssetOperation,
          resources.IAsset
        >("create", assets);
        const request = this.buildRequest<
          services.AssetOperation,
          services.IMutateAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetService.mutateAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAsset
       * @returns services.MutateAssetsResponse
       */
      update: async (
        assets: (resources.IAsset | resources.Asset)[],
        options?: MutateOptions
      ): Promise<services.MutateAssetsResponse> => {
        const ops = this.buildOperations<
          services.AssetOperation,
          resources.IAsset
        >(
          "update",
          assets,
          // @ts-expect-error Static class type here is fine
          resources.Asset
        );
        const request = this.buildRequest<
          services.AssetOperation,
          services.IMutateAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetService.mutateAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetSetAssetService
   */
  public get assetSetAssets() {
    const service = this.loadService<services.AssetSetAssetService>(
      "AssetSetAssetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAssetSetAssetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAssetSetAsset
       * @returns services.MutateAssetSetAssetsResponse
       */
      create: async (
        assetSetAssets: (resources.IAssetSetAsset | resources.AssetSetAsset)[],
        options?: MutateOptions
      ): Promise<services.MutateAssetSetAssetsResponse> => {
        const ops = this.buildOperations<
          services.AssetSetAssetOperation,
          resources.IAssetSetAsset
        >("create", assetSetAssets);
        const request = this.buildRequest<
          services.AssetSetAssetOperation,
          services.IMutateAssetSetAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetSetAssetService.mutateAssetSetAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetSetAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAssetSetAssetsResponse
       */
      remove: async (
        assetSetAssets: string[],
        options?: MutateOptions
      ): Promise<services.MutateAssetSetAssetsResponse> => {
        const ops = this.buildOperations<
          services.AssetSetAssetOperation,
          string
        >("remove", assetSetAssets);
        const request = this.buildRequest<
          services.AssetSetAssetOperation,
          services.IMutateAssetSetAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetSetAssetService.mutateAssetSetAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetSetAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AssetSetService
   */
  public get assetSets() {
    const service = this.loadService<services.AssetSetService>(
      "AssetSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAssetSetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAssetSet
       * @returns services.MutateAssetSetsResponse
       */
      create: async (
        assetSets: (resources.IAssetSet | resources.AssetSet)[],
        options?: MutateOptions
      ): Promise<services.MutateAssetSetsResponse> => {
        const ops = this.buildOperations<
          services.AssetSetOperation,
          resources.IAssetSet
        >("create", assetSets);
        const request = this.buildRequest<
          services.AssetSetOperation,
          services.IMutateAssetSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetSetService.mutateAssetSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAssetSet
       * @returns services.MutateAssetSetsResponse
       */
      update: async (
        assetSets: (resources.IAssetSet | resources.AssetSet)[],
        options?: MutateOptions
      ): Promise<services.MutateAssetSetsResponse> => {
        const ops = this.buildOperations<
          services.AssetSetOperation,
          resources.IAssetSet
        >(
          "update",
          assetSets,
          // @ts-expect-error Static class type here is fine
          resources.AssetSet
        );
        const request = this.buildRequest<
          services.AssetSetOperation,
          services.IMutateAssetSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetSetService.mutateAssetSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAssetSetsResponse
       */
      remove: async (
        assetSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateAssetSetsResponse> => {
        const ops = this.buildOperations<services.AssetSetOperation, string>(
          "remove",
          assetSets
        );
        const request = this.buildRequest<
          services.AssetSetOperation,
          services.IMutateAssetSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetSetService.mutateAssetSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssetSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService
   */
  public get audienceInsights() {
    const service = this.loadService<services.AudienceInsightsService>(
      "AudienceInsightsServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService#generateinsightsfinderreport
       */
      generateInsightsFinderReport: async (
        request: services.GenerateInsightsFinderReportRequest
      ): Promise<services.GenerateInsightsFinderReportResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "AudienceInsightsService.GenerateInsightsFinderReport",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateInsightsFinderReport(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService#listaudienceinsightsattributes
       */
      listAudienceInsightsAttributes: async (
        request: services.ListAudienceInsightsAttributesRequest
      ): Promise<services.ListAudienceInsightsAttributesResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "AudienceInsightsService.ListAudienceInsightsAttributes",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listAudienceInsightsAttributes(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService#listinsightseligibledates
       */
      listInsightsEligibleDates: async (
        request: services.ListInsightsEligibleDatesRequest
      ): Promise<services.ListInsightsEligibleDatesResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "AudienceInsightsService.ListInsightsEligibleDates",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listInsightsEligibleDates(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceInsightsService#generateaudiencecompositioninsights
       */
      generateAudienceCompositionInsights: async (
        request: services.GenerateAudienceCompositionInsightsRequest
      ): Promise<services.GenerateAudienceCompositionInsightsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "AudienceInsightsService.GenerateAudienceCompositionInsights",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateAudienceCompositionInsights(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/AudienceService
   */
  public get audiences() {
    const service = this.loadService<services.AudienceService>(
      "AudienceServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAudiencesRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IAudience
       * @returns services.MutateAudiencesResponse
       */
      create: async (
        audiences: (resources.IAudience | resources.Audience)[],
        options?: MutateOptions
      ): Promise<services.MutateAudiencesResponse> => {
        const ops = this.buildOperations<
          services.AudienceOperation,
          resources.IAudience
        >("create", audiences);
        const request = this.buildRequest<
          services.AudienceOperation,
          services.IMutateAudiencesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AudienceService.mutateAudiences",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAudiences(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAudience
       * @returns services.MutateAudiencesResponse
       */
      update: async (
        audiences: (resources.IAudience | resources.Audience)[],
        options?: MutateOptions
      ): Promise<services.MutateAudiencesResponse> => {
        const ops = this.buildOperations<
          services.AudienceOperation,
          resources.IAudience
        >(
          "update",
          audiences,
          // @ts-expect-error Static class type here is fine
          resources.Audience
        );
        const request = this.buildRequest<
          services.AudienceOperation,
          services.IMutateAudiencesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AudienceService.mutateAudiences",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAudiences(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BatchJobService
   */
  public get batchJobs() {
    const service = this.loadService<services.BatchJobService>(
      "BatchJobServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @description create resources of type resources.IBatchJob
       * @returns services.MutateBatchJobResponse
       */
      create: async (
        batchJobs: (resources.IBatchJob | resources.BatchJob)[],
        options?: MutateOptions
      ): Promise<services.MutateBatchJobResponse> => {
        const ops = this.buildOperations<
          services.BatchJobOperation,
          resources.IBatchJob
        >("create", batchJobs);
        const request = this.buildRequest<
          services.BatchJobOperation,
          services.IMutateBatchJobRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BatchJobService.mutateBatchJob",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBatchJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateBatchJobResponse
       */
      remove: async (
        batchJobs: string[],
        options?: MutateOptions
      ): Promise<services.MutateBatchJobResponse> => {
        const ops = this.buildOperations<services.BatchJobOperation, string>(
          "remove",
          batchJobs
        );
        const request = this.buildRequest<
          services.BatchJobOperation,
          services.IMutateBatchJobRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BatchJobService.mutateBatchJob",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBatchJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BatchJobService#listbatchjobresults
       */
      listBatchJobResults: async (
        request: services.ListBatchJobResultsRequest
      ): Promise<services.ListBatchJobResultsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "BatchJobService.ListBatchJobResults",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listBatchJobResults(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BatchJobService#runbatchjob
       */
      runBatchJob: async (
        request: services.RunBatchJobRequest
      ): Promise<longrunning.Operation> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "BatchJobService.RunBatchJob",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.runBatchJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BatchJobService#addbatchjoboperations
       */
      addBatchJobOperations: async (
        request: services.AddBatchJobOperationsRequest
      ): Promise<services.AddBatchJobOperationsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "BatchJobService.AddBatchJobOperations",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.addBatchJobOperations(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BiddingDataExclusionService
   */
  public get biddingDataExclusions() {
    const service = this.loadService<services.BiddingDataExclusionService>(
      "BiddingDataExclusionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateBiddingDataExclusionsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IBiddingDataExclusion
       * @returns services.MutateBiddingDataExclusionsResponse
       */
      create: async (
        biddingDataExclusions: (
          | resources.IBiddingDataExclusion
          | resources.BiddingDataExclusion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingDataExclusionsResponse> => {
        const ops = this.buildOperations<
          services.BiddingDataExclusionOperation,
          resources.IBiddingDataExclusion
        >("create", biddingDataExclusions);
        const request = this.buildRequest<
          services.BiddingDataExclusionOperation,
          services.IMutateBiddingDataExclusionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BiddingDataExclusionService.mutateBiddingDataExclusions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingDataExclusions(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IBiddingDataExclusion
       * @returns services.MutateBiddingDataExclusionsResponse
       */
      update: async (
        biddingDataExclusions: (
          | resources.IBiddingDataExclusion
          | resources.BiddingDataExclusion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingDataExclusionsResponse> => {
        const ops = this.buildOperations<
          services.BiddingDataExclusionOperation,
          resources.IBiddingDataExclusion
        >(
          "update",
          biddingDataExclusions,
          // @ts-expect-error Static class type here is fine
          resources.BiddingDataExclusion
        );
        const request = this.buildRequest<
          services.BiddingDataExclusionOperation,
          services.IMutateBiddingDataExclusionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BiddingDataExclusionService.mutateBiddingDataExclusions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingDataExclusions(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateBiddingDataExclusionsResponse
       */
      remove: async (
        biddingDataExclusions: string[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingDataExclusionsResponse> => {
        const ops = this.buildOperations<
          services.BiddingDataExclusionOperation,
          string
        >("remove", biddingDataExclusions);
        const request = this.buildRequest<
          services.BiddingDataExclusionOperation,
          services.IMutateBiddingDataExclusionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BiddingDataExclusionService.mutateBiddingDataExclusions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingDataExclusions(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BiddingSeasonalityAdjustmentService
   */
  public get biddingSeasonalityAdjustments() {
    const service =
      this.loadService<services.BiddingSeasonalityAdjustmentService>(
        "BiddingSeasonalityAdjustmentServiceClient"
      );
    type MutateOptions = Partial<
      Pick<
        services.IMutateBiddingSeasonalityAdjustmentsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IBiddingSeasonalityAdjustment
       * @returns services.MutateBiddingSeasonalityAdjustmentsResponse
       */
      create: async (
        biddingSeasonalityAdjustments: (
          | resources.IBiddingSeasonalityAdjustment
          | resources.BiddingSeasonalityAdjustment
        )[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingSeasonalityAdjustmentsResponse> => {
        const ops = this.buildOperations<
          services.BiddingSeasonalityAdjustmentOperation,
          resources.IBiddingSeasonalityAdjustment
        >("create", biddingSeasonalityAdjustments);
        const request = this.buildRequest<
          services.BiddingSeasonalityAdjustmentOperation,
          services.IMutateBiddingSeasonalityAdjustmentsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "BiddingSeasonalityAdjustmentService.mutateBiddingSeasonalityAdjustments",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingSeasonalityAdjustments(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IBiddingSeasonalityAdjustment
       * @returns services.MutateBiddingSeasonalityAdjustmentsResponse
       */
      update: async (
        biddingSeasonalityAdjustments: (
          | resources.IBiddingSeasonalityAdjustment
          | resources.BiddingSeasonalityAdjustment
        )[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingSeasonalityAdjustmentsResponse> => {
        const ops = this.buildOperations<
          services.BiddingSeasonalityAdjustmentOperation,
          resources.IBiddingSeasonalityAdjustment
        >(
          "update",
          biddingSeasonalityAdjustments,
          // @ts-expect-error Static class type here is fine
          resources.BiddingSeasonalityAdjustment
        );
        const request = this.buildRequest<
          services.BiddingSeasonalityAdjustmentOperation,
          services.IMutateBiddingSeasonalityAdjustmentsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "BiddingSeasonalityAdjustmentService.mutateBiddingSeasonalityAdjustments",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingSeasonalityAdjustments(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateBiddingSeasonalityAdjustmentsResponse
       */
      remove: async (
        biddingSeasonalityAdjustments: string[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingSeasonalityAdjustmentsResponse> => {
        const ops = this.buildOperations<
          services.BiddingSeasonalityAdjustmentOperation,
          string
        >("remove", biddingSeasonalityAdjustments);
        const request = this.buildRequest<
          services.BiddingSeasonalityAdjustmentOperation,
          services.IMutateBiddingSeasonalityAdjustmentsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "BiddingSeasonalityAdjustmentService.mutateBiddingSeasonalityAdjustments",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingSeasonalityAdjustments(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BiddingStrategyService
   */
  public get biddingStrategies() {
    const service = this.loadService<services.BiddingStrategyService>(
      "BiddingStrategyServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateBiddingStrategiesRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IBiddingStrategy
       * @returns services.MutateBiddingStrategiesResponse
       */
      create: async (
        biddingStrategies: (
          | resources.IBiddingStrategy
          | resources.BiddingStrategy
        )[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingStrategiesResponse> => {
        const ops = this.buildOperations<
          services.BiddingStrategyOperation,
          resources.IBiddingStrategy
        >("create", biddingStrategies);
        const request = this.buildRequest<
          services.BiddingStrategyOperation,
          services.IMutateBiddingStrategiesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BiddingStrategyService.mutateBiddingStrategies",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingStrategies(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IBiddingStrategy
       * @returns services.MutateBiddingStrategiesResponse
       */
      update: async (
        biddingStrategies: (
          | resources.IBiddingStrategy
          | resources.BiddingStrategy
        )[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingStrategiesResponse> => {
        const ops = this.buildOperations<
          services.BiddingStrategyOperation,
          resources.IBiddingStrategy
        >(
          "update",
          biddingStrategies,
          // @ts-expect-error Static class type here is fine
          resources.BiddingStrategy
        );
        const request = this.buildRequest<
          services.BiddingStrategyOperation,
          services.IMutateBiddingStrategiesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BiddingStrategyService.mutateBiddingStrategies",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingStrategies(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateBiddingStrategiesResponse
       */
      remove: async (
        biddingStrategies: string[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingStrategiesResponse> => {
        const ops = this.buildOperations<
          services.BiddingStrategyOperation,
          string
        >("remove", biddingStrategies);
        const request = this.buildRequest<
          services.BiddingStrategyOperation,
          services.IMutateBiddingStrategiesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BiddingStrategyService.mutateBiddingStrategies",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingStrategies(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignAssetService
   */
  public get campaignAssets() {
    const service = this.loadService<services.CampaignAssetService>(
      "CampaignAssetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignAssetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignAsset
       * @returns services.MutateCampaignAssetsResponse
       */
      create: async (
        campaignAssets: (resources.ICampaignAsset | resources.CampaignAsset)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignAssetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignAssetOperation,
          resources.ICampaignAsset
        >("create", campaignAssets);
        const request = this.buildRequest<
          services.CampaignAssetOperation,
          services.IMutateCampaignAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignAssetService.mutateCampaignAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignAsset
       * @returns services.MutateCampaignAssetsResponse
       */
      update: async (
        campaignAssets: (resources.ICampaignAsset | resources.CampaignAsset)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignAssetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignAssetOperation,
          resources.ICampaignAsset
        >(
          "update",
          campaignAssets,
          // @ts-expect-error Static class type here is fine
          resources.CampaignAsset
        );
        const request = this.buildRequest<
          services.CampaignAssetOperation,
          services.IMutateCampaignAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignAssetService.mutateCampaignAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignAssetsResponse
       */
      remove: async (
        campaignAssets: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignAssetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignAssetOperation,
          string
        >("remove", campaignAssets);
        const request = this.buildRequest<
          services.CampaignAssetOperation,
          services.IMutateCampaignAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignAssetService.mutateCampaignAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignAssetSetService
   */
  public get campaignAssetSets() {
    const service = this.loadService<services.CampaignAssetSetService>(
      "CampaignAssetSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignAssetSetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignAssetSet
       * @returns services.MutateCampaignAssetSetsResponse
       */
      create: async (
        campaignAssetSets: (
          | resources.ICampaignAssetSet
          | resources.CampaignAssetSet
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignAssetSetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignAssetSetOperation,
          resources.ICampaignAssetSet
        >("create", campaignAssetSets);
        const request = this.buildRequest<
          services.CampaignAssetSetOperation,
          services.IMutateCampaignAssetSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignAssetSetService.mutateCampaignAssetSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignAssetSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignAssetSetsResponse
       */
      remove: async (
        campaignAssetSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignAssetSetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignAssetSetOperation,
          string
        >("remove", campaignAssetSets);
        const request = this.buildRequest<
          services.CampaignAssetSetOperation,
          services.IMutateCampaignAssetSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignAssetSetService.mutateCampaignAssetSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignAssetSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignBidModifierService
   */
  public get campaignBidModifiers() {
    const service = this.loadService<services.CampaignBidModifierService>(
      "CampaignBidModifierServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignBidModifiersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignBidModifier
       * @returns services.MutateCampaignBidModifiersResponse
       */
      create: async (
        campaignBidModifiers: (
          | resources.ICampaignBidModifier
          | resources.CampaignBidModifier
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.CampaignBidModifierOperation,
          resources.ICampaignBidModifier
        >("create", campaignBidModifiers);
        const request = this.buildRequest<
          services.CampaignBidModifierOperation,
          services.IMutateCampaignBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBidModifierService.mutateCampaignBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignBidModifier
       * @returns services.MutateCampaignBidModifiersResponse
       */
      update: async (
        campaignBidModifiers: (
          | resources.ICampaignBidModifier
          | resources.CampaignBidModifier
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.CampaignBidModifierOperation,
          resources.ICampaignBidModifier
        >(
          "update",
          campaignBidModifiers,
          // @ts-expect-error Static class type here is fine
          resources.CampaignBidModifier
        );
        const request = this.buildRequest<
          services.CampaignBidModifierOperation,
          services.IMutateCampaignBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBidModifierService.mutateCampaignBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignBidModifiersResponse
       */
      remove: async (
        campaignBidModifiers: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.CampaignBidModifierOperation,
          string
        >("remove", campaignBidModifiers);
        const request = this.buildRequest<
          services.CampaignBidModifierOperation,
          services.IMutateCampaignBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBidModifierService.mutateCampaignBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignBudgetService
   */
  public get campaignBudgets() {
    const service = this.loadService<services.CampaignBudgetService>(
      "CampaignBudgetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignBudgetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignBudget
       * @returns services.MutateCampaignBudgetsResponse
       */
      create: async (
        campaignBudgets: (
          | resources.ICampaignBudget
          | resources.CampaignBudget
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBudgetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignBudgetOperation,
          resources.ICampaignBudget
        >("create", campaignBudgets);
        const request = this.buildRequest<
          services.CampaignBudgetOperation,
          services.IMutateCampaignBudgetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBudgetService.mutateCampaignBudgets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBudgets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignBudget
       * @returns services.MutateCampaignBudgetsResponse
       */
      update: async (
        campaignBudgets: (
          | resources.ICampaignBudget
          | resources.CampaignBudget
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBudgetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignBudgetOperation,
          resources.ICampaignBudget
        >(
          "update",
          campaignBudgets,
          // @ts-expect-error Static class type here is fine
          resources.CampaignBudget
        );
        const request = this.buildRequest<
          services.CampaignBudgetOperation,
          services.IMutateCampaignBudgetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBudgetService.mutateCampaignBudgets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBudgets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignBudgetsResponse
       */
      remove: async (
        campaignBudgets: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBudgetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignBudgetOperation,
          string
        >("remove", campaignBudgets);
        const request = this.buildRequest<
          services.CampaignBudgetOperation,
          services.IMutateCampaignBudgetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBudgetService.mutateCampaignBudgets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBudgets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignConversionGoalService
   */
  public get campaignConversionGoals() {
    const service = this.loadService<services.CampaignConversionGoalService>(
      "CampaignConversionGoalServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateCampaignConversionGoalsRequest, "validate_only">
    >;
    return {
      /**
       * @description update resources of type resources.ICampaignConversionGoal
       * @returns services.MutateCampaignConversionGoalsResponse
       */
      update: async (
        campaignConversionGoals: (
          | resources.ICampaignConversionGoal
          | resources.CampaignConversionGoal
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignConversionGoalsResponse> => {
        const ops = this.buildOperations<
          services.CampaignConversionGoalOperation,
          resources.ICampaignConversionGoal
        >(
          "update",
          campaignConversionGoals,
          // @ts-expect-error Static class type here is fine
          resources.CampaignConversionGoal
        );
        const request = this.buildRequest<
          services.CampaignConversionGoalOperation,
          services.IMutateCampaignConversionGoalsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignConversionGoalService.mutateCampaignConversionGoals",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignConversionGoals(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignCriterionService
   */
  public get campaignCriteria() {
    const service = this.loadService<services.CampaignCriterionService>(
      "CampaignCriterionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignCriteriaRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignCriterion
       * @returns services.MutateCampaignCriteriaResponse
       */
      create: async (
        campaignCriteria: (
          | resources.ICampaignCriterion
          | resources.CampaignCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CampaignCriterionOperation,
          resources.ICampaignCriterion
        >("create", campaignCriteria);
        const request = this.buildRequest<
          services.CampaignCriterionOperation,
          services.IMutateCampaignCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignCriterionService.mutateCampaignCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignCriterion
       * @returns services.MutateCampaignCriteriaResponse
       */
      update: async (
        campaignCriteria: (
          | resources.ICampaignCriterion
          | resources.CampaignCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CampaignCriterionOperation,
          resources.ICampaignCriterion
        >(
          "update",
          campaignCriteria,
          // @ts-expect-error Static class type here is fine
          resources.CampaignCriterion
        );
        const request = this.buildRequest<
          services.CampaignCriterionOperation,
          services.IMutateCampaignCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignCriterionService.mutateCampaignCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignCriteriaResponse
       */
      remove: async (
        campaignCriteria: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CampaignCriterionOperation,
          string
        >("remove", campaignCriteria);
        const request = this.buildRequest<
          services.CampaignCriterionOperation,
          services.IMutateCampaignCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignCriterionService.mutateCampaignCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignCustomizerService
   */
  public get campaignCustomizers() {
    const service = this.loadService<services.CampaignCustomizerService>(
      "CampaignCustomizerServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignCustomizersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignCustomizer
       * @returns services.MutateCampaignCustomizersResponse
       */
      create: async (
        campaignCustomizers: (
          | resources.ICampaignCustomizer
          | resources.CampaignCustomizer
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignCustomizersResponse> => {
        const ops = this.buildOperations<
          services.CampaignCustomizerOperation,
          resources.ICampaignCustomizer
        >("create", campaignCustomizers);
        const request = this.buildRequest<
          services.CampaignCustomizerOperation,
          services.IMutateCampaignCustomizersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignCustomizerService.mutateCampaignCustomizers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignCustomizers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignCustomizersResponse
       */
      remove: async (
        campaignCustomizers: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignCustomizersResponse> => {
        const ops = this.buildOperations<
          services.CampaignCustomizerOperation,
          string
        >("remove", campaignCustomizers);
        const request = this.buildRequest<
          services.CampaignCustomizerOperation,
          services.IMutateCampaignCustomizersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignCustomizerService.mutateCampaignCustomizers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignCustomizers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignDraftService
   */
  public get campaignDrafts() {
    const service = this.loadService<services.CampaignDraftService>(
      "CampaignDraftServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignDraftsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignDraft
       * @returns services.MutateCampaignDraftsResponse
       */
      create: async (
        campaignDrafts: (resources.ICampaignDraft | resources.CampaignDraft)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignDraftsResponse> => {
        const ops = this.buildOperations<
          services.CampaignDraftOperation,
          resources.ICampaignDraft
        >("create", campaignDrafts);
        const request = this.buildRequest<
          services.CampaignDraftOperation,
          services.IMutateCampaignDraftsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignDraftService.mutateCampaignDrafts",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignDrafts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignDraft
       * @returns services.MutateCampaignDraftsResponse
       */
      update: async (
        campaignDrafts: (resources.ICampaignDraft | resources.CampaignDraft)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignDraftsResponse> => {
        const ops = this.buildOperations<
          services.CampaignDraftOperation,
          resources.ICampaignDraft
        >(
          "update",
          campaignDrafts,
          // @ts-expect-error Static class type here is fine
          resources.CampaignDraft
        );
        const request = this.buildRequest<
          services.CampaignDraftOperation,
          services.IMutateCampaignDraftsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignDraftService.mutateCampaignDrafts",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignDrafts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignDraftsResponse
       */
      remove: async (
        campaignDrafts: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignDraftsResponse> => {
        const ops = this.buildOperations<
          services.CampaignDraftOperation,
          string
        >("remove", campaignDrafts);
        const request = this.buildRequest<
          services.CampaignDraftOperation,
          services.IMutateCampaignDraftsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignDraftService.mutateCampaignDrafts",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignDrafts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignDraftService#promotecampaigndraft
       */
      promoteCampaignDraft: async (
        request: services.PromoteCampaignDraftRequest
      ): Promise<longrunning.Operation> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "CampaignDraftService.PromoteCampaignDraft",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.promoteCampaignDraft(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignDraftService#listcampaigndraftasyncerrors
       */
      listCampaignDraftAsyncErrors: async (
        request: services.ListCampaignDraftAsyncErrorsRequest
      ): Promise<services.ListCampaignDraftAsyncErrorsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "CampaignDraftService.ListCampaignDraftAsyncErrors",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listCampaignDraftAsyncErrors(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignExtensionSettingService
   */
  public get campaignExtensionSettings() {
    const service = this.loadService<services.CampaignExtensionSettingService>(
      "CampaignExtensionSettingServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignExtensionSettingsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignExtensionSetting
       * @returns services.MutateCampaignExtensionSettingsResponse
       */
      create: async (
        campaignExtensionSettings: (
          | resources.ICampaignExtensionSetting
          | resources.CampaignExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CampaignExtensionSettingOperation,
          resources.ICampaignExtensionSetting
        >("create", campaignExtensionSettings);
        const request = this.buildRequest<
          services.CampaignExtensionSettingOperation,
          services.IMutateCampaignExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CampaignExtensionSettingService.mutateCampaignExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignExtensionSetting
       * @returns services.MutateCampaignExtensionSettingsResponse
       */
      update: async (
        campaignExtensionSettings: (
          | resources.ICampaignExtensionSetting
          | resources.CampaignExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CampaignExtensionSettingOperation,
          resources.ICampaignExtensionSetting
        >(
          "update",
          campaignExtensionSettings,
          // @ts-expect-error Static class type here is fine
          resources.CampaignExtensionSetting
        );
        const request = this.buildRequest<
          services.CampaignExtensionSettingOperation,
          services.IMutateCampaignExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CampaignExtensionSettingService.mutateCampaignExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignExtensionSettingsResponse
       */
      remove: async (
        campaignExtensionSettings: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CampaignExtensionSettingOperation,
          string
        >("remove", campaignExtensionSettings);
        const request = this.buildRequest<
          services.CampaignExtensionSettingOperation,
          services.IMutateCampaignExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CampaignExtensionSettingService.mutateCampaignExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignFeedService
   */
  public get campaignFeeds() {
    const service = this.loadService<services.CampaignFeedService>(
      "CampaignFeedServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignFeedsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignFeed
       * @returns services.MutateCampaignFeedsResponse
       */
      create: async (
        campaignFeeds: (resources.ICampaignFeed | resources.CampaignFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignFeedsResponse> => {
        const ops = this.buildOperations<
          services.CampaignFeedOperation,
          resources.ICampaignFeed
        >("create", campaignFeeds);
        const request = this.buildRequest<
          services.CampaignFeedOperation,
          services.IMutateCampaignFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignFeedService.mutateCampaignFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignFeed
       * @returns services.MutateCampaignFeedsResponse
       */
      update: async (
        campaignFeeds: (resources.ICampaignFeed | resources.CampaignFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignFeedsResponse> => {
        const ops = this.buildOperations<
          services.CampaignFeedOperation,
          resources.ICampaignFeed
        >(
          "update",
          campaignFeeds,
          // @ts-expect-error Static class type here is fine
          resources.CampaignFeed
        );
        const request = this.buildRequest<
          services.CampaignFeedOperation,
          services.IMutateCampaignFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignFeedService.mutateCampaignFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignFeedsResponse
       */
      remove: async (
        campaignFeeds: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignFeedsResponse> => {
        const ops = this.buildOperations<
          services.CampaignFeedOperation,
          string
        >("remove", campaignFeeds);
        const request = this.buildRequest<
          services.CampaignFeedOperation,
          services.IMutateCampaignFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignFeedService.mutateCampaignFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignGroupService
   */
  public get campaignGroups() {
    const service = this.loadService<services.CampaignGroupService>(
      "CampaignGroupServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignGroupsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignGroup
       * @returns services.MutateCampaignGroupsResponse
       */
      create: async (
        campaignGroups: (resources.ICampaignGroup | resources.CampaignGroup)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignGroupsResponse> => {
        const ops = this.buildOperations<
          services.CampaignGroupOperation,
          resources.ICampaignGroup
        >("create", campaignGroups);
        const request = this.buildRequest<
          services.CampaignGroupOperation,
          services.IMutateCampaignGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignGroupService.mutateCampaignGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignGroup
       * @returns services.MutateCampaignGroupsResponse
       */
      update: async (
        campaignGroups: (resources.ICampaignGroup | resources.CampaignGroup)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignGroupsResponse> => {
        const ops = this.buildOperations<
          services.CampaignGroupOperation,
          resources.ICampaignGroup
        >(
          "update",
          campaignGroups,
          // @ts-expect-error Static class type here is fine
          resources.CampaignGroup
        );
        const request = this.buildRequest<
          services.CampaignGroupOperation,
          services.IMutateCampaignGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignGroupService.mutateCampaignGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignGroupsResponse
       */
      remove: async (
        campaignGroups: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignGroupsResponse> => {
        const ops = this.buildOperations<
          services.CampaignGroupOperation,
          string
        >("remove", campaignGroups);
        const request = this.buildRequest<
          services.CampaignGroupOperation,
          services.IMutateCampaignGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignGroupService.mutateCampaignGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignLabelService
   */
  public get campaignLabels() {
    const service = this.loadService<services.CampaignLabelService>(
      "CampaignLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignLabel
       * @returns services.MutateCampaignLabelsResponse
       */
      create: async (
        campaignLabels: (resources.ICampaignLabel | resources.CampaignLabel)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignLabelsResponse> => {
        const ops = this.buildOperations<
          services.CampaignLabelOperation,
          resources.ICampaignLabel
        >("create", campaignLabels);
        const request = this.buildRequest<
          services.CampaignLabelOperation,
          services.IMutateCampaignLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignLabelService.mutateCampaignLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignLabelsResponse
       */
      remove: async (
        campaignLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignLabelsResponse> => {
        const ops = this.buildOperations<
          services.CampaignLabelOperation,
          string
        >("remove", campaignLabels);
        const request = this.buildRequest<
          services.CampaignLabelOperation,
          services.IMutateCampaignLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignLabelService.mutateCampaignLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignService
   */
  public get campaigns() {
    const service = this.loadService<services.CampaignService>(
      "CampaignServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaign
       * @returns services.MutateCampaignsResponse
       */
      create: async (
        campaigns: (resources.ICampaign | resources.Campaign)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignsResponse> => {
        const ops = this.buildOperations<
          services.CampaignOperation,
          resources.ICampaign
        >("create", campaigns);
        const request = this.buildRequest<
          services.CampaignOperation,
          services.IMutateCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignService.mutateCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaign
       * @returns services.MutateCampaignsResponse
       */
      update: async (
        campaigns: (resources.ICampaign | resources.Campaign)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignsResponse> => {
        const ops = this.buildOperations<
          services.CampaignOperation,
          resources.ICampaign
        >(
          "update",
          campaigns,
          // @ts-expect-error Static class type here is fine
          resources.Campaign
        );
        const request = this.buildRequest<
          services.CampaignOperation,
          services.IMutateCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignService.mutateCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignsResponse
       */
      remove: async (
        campaigns: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignsResponse> => {
        const ops = this.buildOperations<services.CampaignOperation, string>(
          "remove",
          campaigns
        );
        const request = this.buildRequest<
          services.CampaignOperation,
          services.IMutateCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignService.mutateCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CampaignSharedSetService
   */
  public get campaignSharedSets() {
    const service = this.loadService<services.CampaignSharedSetService>(
      "CampaignSharedSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignSharedSetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICampaignSharedSet
       * @returns services.MutateCampaignSharedSetsResponse
       */
      create: async (
        campaignSharedSets: (
          | resources.ICampaignSharedSet
          | resources.CampaignSharedSet
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignSharedSetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignSharedSetOperation,
          resources.ICampaignSharedSet
        >("create", campaignSharedSets);
        const request = this.buildRequest<
          services.CampaignSharedSetOperation,
          services.IMutateCampaignSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignSharedSetService.mutateCampaignSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignSharedSetsResponse
       */
      remove: async (
        campaignSharedSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignSharedSetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignSharedSetOperation,
          string
        >("remove", campaignSharedSets);
        const request = this.buildRequest<
          services.CampaignSharedSetOperation,
          services.IMutateCampaignSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignSharedSetService.mutateCampaignSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionActionService
   */
  public get conversionActions() {
    const service = this.loadService<services.ConversionActionService>(
      "ConversionActionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateConversionActionsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IConversionAction
       * @returns services.MutateConversionActionsResponse
       */
      create: async (
        conversionActions: (
          | resources.IConversionAction
          | resources.ConversionAction
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionActionsResponse> => {
        const ops = this.buildOperations<
          services.ConversionActionOperation,
          resources.IConversionAction
        >("create", conversionActions);
        const request = this.buildRequest<
          services.ConversionActionOperation,
          services.IMutateConversionActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionActionService.mutateConversionActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IConversionAction
       * @returns services.MutateConversionActionsResponse
       */
      update: async (
        conversionActions: (
          | resources.IConversionAction
          | resources.ConversionAction
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionActionsResponse> => {
        const ops = this.buildOperations<
          services.ConversionActionOperation,
          resources.IConversionAction
        >(
          "update",
          conversionActions,
          // @ts-expect-error Static class type here is fine
          resources.ConversionAction
        );
        const request = this.buildRequest<
          services.ConversionActionOperation,
          services.IMutateConversionActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionActionService.mutateConversionActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateConversionActionsResponse
       */
      remove: async (
        conversionActions: string[],
        options?: MutateOptions
      ): Promise<services.MutateConversionActionsResponse> => {
        const ops = this.buildOperations<
          services.ConversionActionOperation,
          string
        >("remove", conversionActions);
        const request = this.buildRequest<
          services.ConversionActionOperation,
          services.IMutateConversionActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionActionService.mutateConversionActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionCustomVariableService
   */
  public get conversionCustomVariables() {
    const service = this.loadService<services.ConversionCustomVariableService>(
      "ConversionCustomVariableServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateConversionCustomVariablesRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IConversionCustomVariable
       * @returns services.MutateConversionCustomVariablesResponse
       */
      create: async (
        conversionCustomVariables: (
          | resources.IConversionCustomVariable
          | resources.ConversionCustomVariable
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionCustomVariablesResponse> => {
        const ops = this.buildOperations<
          services.ConversionCustomVariableOperation,
          resources.IConversionCustomVariable
        >("create", conversionCustomVariables);
        const request = this.buildRequest<
          services.ConversionCustomVariableOperation,
          services.IMutateConversionCustomVariablesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "ConversionCustomVariableService.mutateConversionCustomVariables",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionCustomVariables(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IConversionCustomVariable
       * @returns services.MutateConversionCustomVariablesResponse
       */
      update: async (
        conversionCustomVariables: (
          | resources.IConversionCustomVariable
          | resources.ConversionCustomVariable
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionCustomVariablesResponse> => {
        const ops = this.buildOperations<
          services.ConversionCustomVariableOperation,
          resources.IConversionCustomVariable
        >(
          "update",
          conversionCustomVariables,
          // @ts-expect-error Static class type here is fine
          resources.ConversionCustomVariable
        );
        const request = this.buildRequest<
          services.ConversionCustomVariableOperation,
          services.IMutateConversionCustomVariablesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "ConversionCustomVariableService.mutateConversionCustomVariables",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionCustomVariables(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionGoalCampaignConfigService
   */
  public get conversionGoalCampaignConfigs() {
    const service =
      this.loadService<services.ConversionGoalCampaignConfigService>(
        "ConversionGoalCampaignConfigServiceClient"
      );
    type MutateOptions = Partial<
      Pick<
        services.IMutateConversionGoalCampaignConfigsRequest,
        "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description update resources of type resources.IConversionGoalCampaignConfig
       * @returns services.MutateConversionGoalCampaignConfigsResponse
       */
      update: async (
        conversionGoalCampaignConfigs: (
          | resources.IConversionGoalCampaignConfig
          | resources.ConversionGoalCampaignConfig
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionGoalCampaignConfigsResponse> => {
        const ops = this.buildOperations<
          services.ConversionGoalCampaignConfigOperation,
          resources.IConversionGoalCampaignConfig
        >(
          "update",
          conversionGoalCampaignConfigs,
          // @ts-expect-error Static class type here is fine
          resources.ConversionGoalCampaignConfig
        );
        const request = this.buildRequest<
          services.ConversionGoalCampaignConfigOperation,
          services.IMutateConversionGoalCampaignConfigsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "ConversionGoalCampaignConfigService.mutateConversionGoalCampaignConfigs",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionGoalCampaignConfigs(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionValueRuleService
   */
  public get conversionValueRules() {
    const service = this.loadService<services.ConversionValueRuleService>(
      "ConversionValueRuleServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateConversionValueRulesRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IConversionValueRule
       * @returns services.MutateConversionValueRulesResponse
       */
      create: async (
        conversionValueRules: (
          | resources.IConversionValueRule
          | resources.ConversionValueRule
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionValueRulesResponse> => {
        const ops = this.buildOperations<
          services.ConversionValueRuleOperation,
          resources.IConversionValueRule
        >("create", conversionValueRules);
        const request = this.buildRequest<
          services.ConversionValueRuleOperation,
          services.IMutateConversionValueRulesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionValueRuleService.mutateConversionValueRules",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionValueRules(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IConversionValueRule
       * @returns services.MutateConversionValueRulesResponse
       */
      update: async (
        conversionValueRules: (
          | resources.IConversionValueRule
          | resources.ConversionValueRule
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionValueRulesResponse> => {
        const ops = this.buildOperations<
          services.ConversionValueRuleOperation,
          resources.IConversionValueRule
        >(
          "update",
          conversionValueRules,
          // @ts-expect-error Static class type here is fine
          resources.ConversionValueRule
        );
        const request = this.buildRequest<
          services.ConversionValueRuleOperation,
          services.IMutateConversionValueRulesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionValueRuleService.mutateConversionValueRules",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionValueRules(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateConversionValueRulesResponse
       */
      remove: async (
        conversionValueRules: string[],
        options?: MutateOptions
      ): Promise<services.MutateConversionValueRulesResponse> => {
        const ops = this.buildOperations<
          services.ConversionValueRuleOperation,
          string
        >("remove", conversionValueRules);
        const request = this.buildRequest<
          services.ConversionValueRuleOperation,
          services.IMutateConversionValueRulesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionValueRuleService.mutateConversionValueRules",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionValueRules(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionValueRuleSetService
   */
  public get conversionValueRuleSets() {
    const service = this.loadService<services.ConversionValueRuleSetService>(
      "ConversionValueRuleSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateConversionValueRuleSetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IConversionValueRuleSet
       * @returns services.MutateConversionValueRuleSetsResponse
       */
      create: async (
        conversionValueRuleSets: (
          | resources.IConversionValueRuleSet
          | resources.ConversionValueRuleSet
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionValueRuleSetsResponse> => {
        const ops = this.buildOperations<
          services.ConversionValueRuleSetOperation,
          resources.IConversionValueRuleSet
        >("create", conversionValueRuleSets);
        const request = this.buildRequest<
          services.ConversionValueRuleSetOperation,
          services.IMutateConversionValueRuleSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionValueRuleSetService.mutateConversionValueRuleSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionValueRuleSets(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IConversionValueRuleSet
       * @returns services.MutateConversionValueRuleSetsResponse
       */
      update: async (
        conversionValueRuleSets: (
          | resources.IConversionValueRuleSet
          | resources.ConversionValueRuleSet
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionValueRuleSetsResponse> => {
        const ops = this.buildOperations<
          services.ConversionValueRuleSetOperation,
          resources.IConversionValueRuleSet
        >(
          "update",
          conversionValueRuleSets,
          // @ts-expect-error Static class type here is fine
          resources.ConversionValueRuleSet
        );
        const request = this.buildRequest<
          services.ConversionValueRuleSetOperation,
          services.IMutateConversionValueRuleSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionValueRuleSetService.mutateConversionValueRuleSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionValueRuleSets(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateConversionValueRuleSetsResponse
       */
      remove: async (
        conversionValueRuleSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateConversionValueRuleSetsResponse> => {
        const ops = this.buildOperations<
          services.ConversionValueRuleSetOperation,
          string
        >("remove", conversionValueRuleSets);
        const request = this.buildRequest<
          services.ConversionValueRuleSetOperation,
          services.IMutateConversionValueRuleSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionValueRuleSetService.mutateConversionValueRuleSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionValueRuleSets(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomConversionGoalService
   */
  public get customConversionGoals() {
    const service = this.loadService<services.CustomConversionGoalService>(
      "CustomConversionGoalServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomConversionGoalsRequest,
        "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICustomConversionGoal
       * @returns services.MutateCustomConversionGoalsResponse
       */
      create: async (
        customConversionGoals: (
          | resources.ICustomConversionGoal
          | resources.CustomConversionGoal
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomConversionGoalsResponse> => {
        const ops = this.buildOperations<
          services.CustomConversionGoalOperation,
          resources.ICustomConversionGoal
        >("create", customConversionGoals);
        const request = this.buildRequest<
          services.CustomConversionGoalOperation,
          services.IMutateCustomConversionGoalsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomConversionGoalService.mutateCustomConversionGoals",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomConversionGoals(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomConversionGoal
       * @returns services.MutateCustomConversionGoalsResponse
       */
      update: async (
        customConversionGoals: (
          | resources.ICustomConversionGoal
          | resources.CustomConversionGoal
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomConversionGoalsResponse> => {
        const ops = this.buildOperations<
          services.CustomConversionGoalOperation,
          resources.ICustomConversionGoal
        >(
          "update",
          customConversionGoals,
          // @ts-expect-error Static class type here is fine
          resources.CustomConversionGoal
        );
        const request = this.buildRequest<
          services.CustomConversionGoalOperation,
          services.IMutateCustomConversionGoalsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomConversionGoalService.mutateCustomConversionGoals",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomConversionGoals(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomConversionGoalsResponse
       */
      remove: async (
        customConversionGoals: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomConversionGoalsResponse> => {
        const ops = this.buildOperations<
          services.CustomConversionGoalOperation,
          string
        >("remove", customConversionGoals);
        const request = this.buildRequest<
          services.CustomConversionGoalOperation,
          services.IMutateCustomConversionGoalsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomConversionGoalService.mutateCustomConversionGoals",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomConversionGoals(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerAssetService
   */
  public get customerAssets() {
    const service = this.loadService<services.CustomerAssetService>(
      "CustomerAssetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerAssetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICustomerAsset
       * @returns services.MutateCustomerAssetsResponse
       */
      create: async (
        customerAssets: (resources.ICustomerAsset | resources.CustomerAsset)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerAssetsResponse> => {
        const ops = this.buildOperations<
          services.CustomerAssetOperation,
          resources.ICustomerAsset
        >("create", customerAssets);
        const request = this.buildRequest<
          services.CustomerAssetOperation,
          services.IMutateCustomerAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerAssetService.mutateCustomerAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomerAsset
       * @returns services.MutateCustomerAssetsResponse
       */
      update: async (
        customerAssets: (resources.ICustomerAsset | resources.CustomerAsset)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerAssetsResponse> => {
        const ops = this.buildOperations<
          services.CustomerAssetOperation,
          resources.ICustomerAsset
        >(
          "update",
          customerAssets,
          // @ts-expect-error Static class type here is fine
          resources.CustomerAsset
        );
        const request = this.buildRequest<
          services.CustomerAssetOperation,
          services.IMutateCustomerAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerAssetService.mutateCustomerAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerAssetsResponse
       */
      remove: async (
        customerAssets: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerAssetsResponse> => {
        const ops = this.buildOperations<
          services.CustomerAssetOperation,
          string
        >("remove", customerAssets);
        const request = this.buildRequest<
          services.CustomerAssetOperation,
          services.IMutateCustomerAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerAssetService.mutateCustomerAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerConversionGoalService
   */
  public get customerConversionGoals() {
    const service = this.loadService<services.CustomerConversionGoalService>(
      "CustomerConversionGoalServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateCustomerConversionGoalsRequest, "validate_only">
    >;
    return {
      /**
       * @description update resources of type resources.ICustomerConversionGoal
       * @returns services.MutateCustomerConversionGoalsResponse
       */
      update: async (
        customerConversionGoals: (
          | resources.ICustomerConversionGoal
          | resources.CustomerConversionGoal
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerConversionGoalsResponse> => {
        const ops = this.buildOperations<
          services.CustomerConversionGoalOperation,
          resources.ICustomerConversionGoal
        >(
          "update",
          customerConversionGoals,
          // @ts-expect-error Static class type here is fine
          resources.CustomerConversionGoal
        );
        const request = this.buildRequest<
          services.CustomerConversionGoalOperation,
          services.IMutateCustomerConversionGoalsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerConversionGoalService.mutateCustomerConversionGoals",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerConversionGoals(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerCustomizerService
   */
  public get customerCustomizers() {
    const service = this.loadService<services.CustomerCustomizerService>(
      "CustomerCustomizerServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerCustomizersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICustomerCustomizer
       * @returns services.MutateCustomerCustomizersResponse
       */
      create: async (
        customerCustomizers: (
          | resources.ICustomerCustomizer
          | resources.CustomerCustomizer
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerCustomizersResponse> => {
        const ops = this.buildOperations<
          services.CustomerCustomizerOperation,
          resources.ICustomerCustomizer
        >("create", customerCustomizers);
        const request = this.buildRequest<
          services.CustomerCustomizerOperation,
          services.IMutateCustomerCustomizersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerCustomizerService.mutateCustomerCustomizers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerCustomizers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerCustomizersResponse
       */
      remove: async (
        customerCustomizers: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerCustomizersResponse> => {
        const ops = this.buildOperations<
          services.CustomerCustomizerOperation,
          string
        >("remove", customerCustomizers);
        const request = this.buildRequest<
          services.CustomerCustomizerOperation,
          services.IMutateCustomerCustomizersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerCustomizerService.mutateCustomerCustomizers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerCustomizers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerExtensionSettingService
   */
  public get customerExtensionSettings() {
    const service = this.loadService<services.CustomerExtensionSettingService>(
      "CustomerExtensionSettingServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerExtensionSettingsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICustomerExtensionSetting
       * @returns services.MutateCustomerExtensionSettingsResponse
       */
      create: async (
        customerExtensionSettings: (
          | resources.ICustomerExtensionSetting
          | resources.CustomerExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CustomerExtensionSettingOperation,
          resources.ICustomerExtensionSetting
        >("create", customerExtensionSettings);
        const request = this.buildRequest<
          services.CustomerExtensionSettingOperation,
          services.IMutateCustomerExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerExtensionSettingService.mutateCustomerExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomerExtensionSetting
       * @returns services.MutateCustomerExtensionSettingsResponse
       */
      update: async (
        customerExtensionSettings: (
          | resources.ICustomerExtensionSetting
          | resources.CustomerExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CustomerExtensionSettingOperation,
          resources.ICustomerExtensionSetting
        >(
          "update",
          customerExtensionSettings,
          // @ts-expect-error Static class type here is fine
          resources.CustomerExtensionSetting
        );
        const request = this.buildRequest<
          services.CustomerExtensionSettingOperation,
          services.IMutateCustomerExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerExtensionSettingService.mutateCustomerExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerExtensionSettingsResponse
       */
      remove: async (
        customerExtensionSettings: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CustomerExtensionSettingOperation,
          string
        >("remove", customerExtensionSettings);
        const request = this.buildRequest<
          services.CustomerExtensionSettingOperation,
          services.IMutateCustomerExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerExtensionSettingService.mutateCustomerExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerFeedService
   */
  public get customerFeeds() {
    const service = this.loadService<services.CustomerFeedService>(
      "CustomerFeedServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerFeedsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICustomerFeed
       * @returns services.MutateCustomerFeedsResponse
       */
      create: async (
        customerFeeds: (resources.ICustomerFeed | resources.CustomerFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerFeedsResponse> => {
        const ops = this.buildOperations<
          services.CustomerFeedOperation,
          resources.ICustomerFeed
        >("create", customerFeeds);
        const request = this.buildRequest<
          services.CustomerFeedOperation,
          services.IMutateCustomerFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerFeedService.mutateCustomerFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomerFeed
       * @returns services.MutateCustomerFeedsResponse
       */
      update: async (
        customerFeeds: (resources.ICustomerFeed | resources.CustomerFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerFeedsResponse> => {
        const ops = this.buildOperations<
          services.CustomerFeedOperation,
          resources.ICustomerFeed
        >(
          "update",
          customerFeeds,
          // @ts-expect-error Static class type here is fine
          resources.CustomerFeed
        );
        const request = this.buildRequest<
          services.CustomerFeedOperation,
          services.IMutateCustomerFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerFeedService.mutateCustomerFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerFeedsResponse
       */
      remove: async (
        customerFeeds: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerFeedsResponse> => {
        const ops = this.buildOperations<
          services.CustomerFeedOperation,
          string
        >("remove", customerFeeds);
        const request = this.buildRequest<
          services.CustomerFeedOperation,
          services.IMutateCustomerFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerFeedService.mutateCustomerFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerLabelService
   */
  public get customerLabels() {
    const service = this.loadService<services.CustomerLabelService>(
      "CustomerLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICustomerLabel
       * @returns services.MutateCustomerLabelsResponse
       */
      create: async (
        customerLabels: (resources.ICustomerLabel | resources.CustomerLabel)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerLabelsResponse> => {
        const ops = this.buildOperations<
          services.CustomerLabelOperation,
          resources.ICustomerLabel
        >("create", customerLabels);
        const request = this.buildRequest<
          services.CustomerLabelOperation,
          services.IMutateCustomerLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerLabelService.mutateCustomerLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerLabelsResponse
       */
      remove: async (
        customerLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerLabelsResponse> => {
        const ops = this.buildOperations<
          services.CustomerLabelOperation,
          string
        >("remove", customerLabels);
        const request = this.buildRequest<
          services.CustomerLabelOperation,
          services.IMutateCustomerLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerLabelService.mutateCustomerLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerNegativeCriterionService
   */
  public get customerNegativeCriteria() {
    const service = this.loadService<services.CustomerNegativeCriterionService>(
      "CustomerNegativeCriterionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerNegativeCriteriaRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICustomerNegativeCriterion
       * @returns services.MutateCustomerNegativeCriteriaResponse
       */
      create: async (
        customerNegativeCriteria: (
          | resources.ICustomerNegativeCriterion
          | resources.CustomerNegativeCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerNegativeCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CustomerNegativeCriterionOperation,
          resources.ICustomerNegativeCriterion
        >("create", customerNegativeCriteria);
        const request = this.buildRequest<
          services.CustomerNegativeCriterionOperation,
          services.IMutateCustomerNegativeCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerNegativeCriterionService.mutateCustomerNegativeCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerNegativeCriteria(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerNegativeCriteriaResponse
       */
      remove: async (
        customerNegativeCriteria: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerNegativeCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CustomerNegativeCriterionOperation,
          string
        >("remove", customerNegativeCriteria);
        const request = this.buildRequest<
          services.CustomerNegativeCriterionOperation,
          services.IMutateCustomerNegativeCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerNegativeCriterionService.mutateCustomerNegativeCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerNegativeCriteria(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerService
   */
  public get customers() {
    const service = this.loadService<services.CustomerService>(
      "CustomerServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerRequest,
        "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description update resources of type resources.ICustomer
       * @returns services.MutateCustomerResponse
       */
      update: async (
        customers: (resources.ICustomer | resources.Customer)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerResponse> => {
        const ops = this.buildOperations<
          services.CustomerOperation,
          resources.ICustomer
        >(
          "update",
          customers,
          // @ts-expect-error Static class type here is fine
          resources.Customer
        );
        const request = this.buildRequest<
          services.CustomerOperation,
          services.IMutateCustomerRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerService.mutateCustomer",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomer(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerService#listaccessiblecustomers
       */
      listAccessibleCustomers: async (
        request: services.ListAccessibleCustomersRequest
      ): Promise<services.ListAccessibleCustomersResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "CustomerService.ListAccessibleCustomers",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listAccessibleCustomers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerService#createcustomerclient
       */
      createCustomerClient: async (
        request: services.CreateCustomerClientRequest
      ): Promise<services.CreateCustomerClientResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "CustomerService.CreateCustomerClient",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.createCustomerClient(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomizerAttributeService
   */
  public get customizerAttributes() {
    const service = this.loadService<services.CustomizerAttributeService>(
      "CustomizerAttributeServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomizerAttributesRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICustomizerAttribute
       * @returns services.MutateCustomizerAttributesResponse
       */
      create: async (
        customizerAttributes: (
          | resources.ICustomizerAttribute
          | resources.CustomizerAttribute
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomizerAttributesResponse> => {
        const ops = this.buildOperations<
          services.CustomizerAttributeOperation,
          resources.ICustomizerAttribute
        >("create", customizerAttributes);
        const request = this.buildRequest<
          services.CustomizerAttributeOperation,
          services.IMutateCustomizerAttributesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomizerAttributeService.mutateCustomizerAttributes",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomizerAttributes(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomizerAttributesResponse
       */
      remove: async (
        customizerAttributes: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomizerAttributesResponse> => {
        const ops = this.buildOperations<
          services.CustomizerAttributeOperation,
          string
        >("remove", customizerAttributes);
        const request = this.buildRequest<
          services.CustomizerAttributeOperation,
          services.IMutateCustomizerAttributesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomizerAttributeService.mutateCustomizerAttributes",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomizerAttributes(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentArmService
   */
  public get experimentArms() {
    const service = this.loadService<services.ExperimentArmService>(
      "ExperimentArmServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateExperimentArmsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IExperimentArm
       * @returns services.MutateExperimentArmsResponse
       */
      create: async (
        experimentArms: (resources.IExperimentArm | resources.ExperimentArm)[],
        options?: MutateOptions
      ): Promise<services.MutateExperimentArmsResponse> => {
        const ops = this.buildOperations<
          services.ExperimentArmOperation,
          resources.IExperimentArm
        >("create", experimentArms);
        const request = this.buildRequest<
          services.ExperimentArmOperation,
          services.IMutateExperimentArmsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExperimentArmService.mutateExperimentArms",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExperimentArms(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IExperimentArm
       * @returns services.MutateExperimentArmsResponse
       */
      update: async (
        experimentArms: (resources.IExperimentArm | resources.ExperimentArm)[],
        options?: MutateOptions
      ): Promise<services.MutateExperimentArmsResponse> => {
        const ops = this.buildOperations<
          services.ExperimentArmOperation,
          resources.IExperimentArm
        >(
          "update",
          experimentArms,
          // @ts-expect-error Static class type here is fine
          resources.ExperimentArm
        );
        const request = this.buildRequest<
          services.ExperimentArmOperation,
          services.IMutateExperimentArmsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExperimentArmService.mutateExperimentArms",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExperimentArms(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateExperimentArmsResponse
       */
      remove: async (
        experimentArms: string[],
        options?: MutateOptions
      ): Promise<services.MutateExperimentArmsResponse> => {
        const ops = this.buildOperations<
          services.ExperimentArmOperation,
          string
        >("remove", experimentArms);
        const request = this.buildRequest<
          services.ExperimentArmOperation,
          services.IMutateExperimentArmsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExperimentArmService.mutateExperimentArms",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExperimentArms(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService
   */
  public get experiments() {
    const service = this.loadService<services.ExperimentService>(
      "ExperimentServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateExperimentsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IExperiment
       * @returns services.MutateExperimentsResponse
       */
      create: async (
        experiments: (resources.IExperiment | resources.Experiment)[],
        options?: MutateOptions
      ): Promise<services.MutateExperimentsResponse> => {
        const ops = this.buildOperations<
          services.ExperimentOperation,
          resources.IExperiment
        >("create", experiments);
        const request = this.buildRequest<
          services.ExperimentOperation,
          services.IMutateExperimentsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExperimentService.mutateExperiments",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExperiments(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IExperiment
       * @returns services.MutateExperimentsResponse
       */
      update: async (
        experiments: (resources.IExperiment | resources.Experiment)[],
        options?: MutateOptions
      ): Promise<services.MutateExperimentsResponse> => {
        const ops = this.buildOperations<
          services.ExperimentOperation,
          resources.IExperiment
        >(
          "update",
          experiments,
          // @ts-expect-error Static class type here is fine
          resources.Experiment
        );
        const request = this.buildRequest<
          services.ExperimentOperation,
          services.IMutateExperimentsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExperimentService.mutateExperiments",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExperiments(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateExperimentsResponse
       */
      remove: async (
        experiments: string[],
        options?: MutateOptions
      ): Promise<services.MutateExperimentsResponse> => {
        const ops = this.buildOperations<services.ExperimentOperation, string>(
          "remove",
          experiments
        );
        const request = this.buildRequest<
          services.ExperimentOperation,
          services.IMutateExperimentsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExperimentService.mutateExperiments",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExperiments(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#endexperiment
       */
      endExperiment: async (
        request: services.EndExperimentRequest
      ): Promise<protobuf.Empty> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ExperimentService.EndExperiment",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.endExperiment(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#listexperimentasyncerrors
       */
      listExperimentAsyncErrors: async (
        request: services.ListExperimentAsyncErrorsRequest
      ): Promise<services.ListExperimentAsyncErrorsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ExperimentService.ListExperimentAsyncErrors",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listExperimentAsyncErrors(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#graduateexperiment
       */
      graduateExperiment: async (
        request: services.GraduateExperimentRequest
      ): Promise<protobuf.Empty> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ExperimentService.GraduateExperiment",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.graduateExperiment(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#scheduleexperiment
       */
      scheduleExperiment: async (
        request: services.ScheduleExperimentRequest
      ): Promise<longrunning.Operation> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ExperimentService.ScheduleExperiment",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.scheduleExperiment(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExperimentService#promoteexperiment
       */
      promoteExperiment: async (
        request: services.PromoteExperimentRequest
      ): Promise<longrunning.Operation> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ExperimentService.PromoteExperiment",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.promoteExperiment(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ExtensionFeedItemService
   */
  public get extensionFeedItems() {
    const service = this.loadService<services.ExtensionFeedItemService>(
      "ExtensionFeedItemServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateExtensionFeedItemsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IExtensionFeedItem
       * @returns services.MutateExtensionFeedItemsResponse
       */
      create: async (
        extensionFeedItems: (
          | resources.IExtensionFeedItem
          | resources.ExtensionFeedItem
        )[],
        options?: MutateOptions
      ): Promise<services.MutateExtensionFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.ExtensionFeedItemOperation,
          resources.IExtensionFeedItem
        >("create", extensionFeedItems);
        const request = this.buildRequest<
          services.ExtensionFeedItemOperation,
          services.IMutateExtensionFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExtensionFeedItemService.mutateExtensionFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExtensionFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IExtensionFeedItem
       * @returns services.MutateExtensionFeedItemsResponse
       */
      update: async (
        extensionFeedItems: (
          | resources.IExtensionFeedItem
          | resources.ExtensionFeedItem
        )[],
        options?: MutateOptions
      ): Promise<services.MutateExtensionFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.ExtensionFeedItemOperation,
          resources.IExtensionFeedItem
        >(
          "update",
          extensionFeedItems,
          // @ts-expect-error Static class type here is fine
          resources.ExtensionFeedItem
        );
        const request = this.buildRequest<
          services.ExtensionFeedItemOperation,
          services.IMutateExtensionFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExtensionFeedItemService.mutateExtensionFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExtensionFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateExtensionFeedItemsResponse
       */
      remove: async (
        extensionFeedItems: string[],
        options?: MutateOptions
      ): Promise<services.MutateExtensionFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.ExtensionFeedItemOperation,
          string
        >("remove", extensionFeedItems);
        const request = this.buildRequest<
          services.ExtensionFeedItemOperation,
          services.IMutateExtensionFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExtensionFeedItemService.mutateExtensionFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExtensionFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedItemService
   */
  public get feedItems() {
    const service = this.loadService<services.FeedItemService>(
      "FeedItemServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedItemsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IFeedItem
       * @returns services.MutateFeedItemsResponse
       */
      create: async (
        feedItems: (resources.IFeedItem | resources.FeedItem)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemOperation,
          resources.IFeedItem
        >("create", feedItems);
        const request = this.buildRequest<
          services.FeedItemOperation,
          services.IMutateFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemService.mutateFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IFeedItem
       * @returns services.MutateFeedItemsResponse
       */
      update: async (
        feedItems: (resources.IFeedItem | resources.FeedItem)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemOperation,
          resources.IFeedItem
        >(
          "update",
          feedItems,
          // @ts-expect-error Static class type here is fine
          resources.FeedItem
        );
        const request = this.buildRequest<
          services.FeedItemOperation,
          services.IMutateFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemService.mutateFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedItemsResponse
       */
      remove: async (
        feedItems: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemsResponse> => {
        const ops = this.buildOperations<services.FeedItemOperation, string>(
          "remove",
          feedItems
        );
        const request = this.buildRequest<
          services.FeedItemOperation,
          services.IMutateFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemService.mutateFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedItemSetLinkService
   */
  public get feedItemSetLinks() {
    const service = this.loadService<services.FeedItemSetLinkService>(
      "FeedItemSetLinkServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedItemSetLinksRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IFeedItemSetLink
       * @returns services.MutateFeedItemSetLinksResponse
       */
      create: async (
        feedItemSetLinks: (
          | resources.IFeedItemSetLink
          | resources.FeedItemSetLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetLinksResponse> => {
        const ops = this.buildOperations<
          services.FeedItemSetLinkOperation,
          resources.IFeedItemSetLink
        >("create", feedItemSetLinks);
        const request = this.buildRequest<
          services.FeedItemSetLinkOperation,
          services.IMutateFeedItemSetLinksRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetLinkService.mutateFeedItemSetLinks",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSetLinks(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedItemSetLinksResponse
       */
      remove: async (
        feedItemSetLinks: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetLinksResponse> => {
        const ops = this.buildOperations<
          services.FeedItemSetLinkOperation,
          string
        >("remove", feedItemSetLinks);
        const request = this.buildRequest<
          services.FeedItemSetLinkOperation,
          services.IMutateFeedItemSetLinksRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetLinkService.mutateFeedItemSetLinks",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSetLinks(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedItemSetService
   */
  public get feedItemSets() {
    const service = this.loadService<services.FeedItemSetService>(
      "FeedItemSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedItemSetsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IFeedItemSet
       * @returns services.MutateFeedItemSetsResponse
       */
      create: async (
        feedItemSets: (resources.IFeedItemSet | resources.FeedItemSet)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemSetOperation,
          resources.IFeedItemSet
        >("create", feedItemSets);
        const request = this.buildRequest<
          services.FeedItemSetOperation,
          services.IMutateFeedItemSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetService.mutateFeedItemSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IFeedItemSet
       * @returns services.MutateFeedItemSetsResponse
       */
      update: async (
        feedItemSets: (resources.IFeedItemSet | resources.FeedItemSet)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemSetOperation,
          resources.IFeedItemSet
        >(
          "update",
          feedItemSets,
          // @ts-expect-error Static class type here is fine
          resources.FeedItemSet
        );
        const request = this.buildRequest<
          services.FeedItemSetOperation,
          services.IMutateFeedItemSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetService.mutateFeedItemSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedItemSetsResponse
       */
      remove: async (
        feedItemSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetsResponse> => {
        const ops = this.buildOperations<services.FeedItemSetOperation, string>(
          "remove",
          feedItemSets
        );
        const request = this.buildRequest<
          services.FeedItemSetOperation,
          services.IMutateFeedItemSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetService.mutateFeedItemSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedItemTargetService
   */
  public get feedItemTargets() {
    const service = this.loadService<services.FeedItemTargetService>(
      "FeedItemTargetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedItemTargetsRequest,
        "partial_failure" | "response_content_type" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IFeedItemTarget
       * @returns services.MutateFeedItemTargetsResponse
       */
      create: async (
        feedItemTargets: (
          | resources.IFeedItemTarget
          | resources.FeedItemTarget
        )[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemTargetsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemTargetOperation,
          resources.IFeedItemTarget
        >("create", feedItemTargets);
        const request = this.buildRequest<
          services.FeedItemTargetOperation,
          services.IMutateFeedItemTargetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemTargetService.mutateFeedItemTargets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemTargets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedItemTargetsResponse
       */
      remove: async (
        feedItemTargets: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemTargetsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemTargetOperation,
          string
        >("remove", feedItemTargets);
        const request = this.buildRequest<
          services.FeedItemTargetOperation,
          services.IMutateFeedItemTargetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemTargetService.mutateFeedItemTargets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemTargets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedMappingService
   */
  public get feedMappings() {
    const service = this.loadService<services.FeedMappingService>(
      "FeedMappingServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedMappingsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IFeedMapping
       * @returns services.MutateFeedMappingsResponse
       */
      create: async (
        feedMappings: (resources.IFeedMapping | resources.FeedMapping)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedMappingsResponse> => {
        const ops = this.buildOperations<
          services.FeedMappingOperation,
          resources.IFeedMapping
        >("create", feedMappings);
        const request = this.buildRequest<
          services.FeedMappingOperation,
          services.IMutateFeedMappingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedMappingService.mutateFeedMappings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedMappings(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedMappingsResponse
       */
      remove: async (
        feedMappings: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedMappingsResponse> => {
        const ops = this.buildOperations<services.FeedMappingOperation, string>(
          "remove",
          feedMappings
        );
        const request = this.buildRequest<
          services.FeedMappingOperation,
          services.IMutateFeedMappingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedMappingService.mutateFeedMappings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedMappings(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/FeedService
   */
  public get feeds() {
    const service = this.loadService<services.FeedService>("FeedServiceClient");
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IFeed
       * @returns services.MutateFeedsResponse
       */
      create: async (
        feeds: (resources.IFeed | resources.Feed)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedsResponse> => {
        const ops = this.buildOperations<
          services.FeedOperation,
          resources.IFeed
        >("create", feeds);
        const request = this.buildRequest<
          services.FeedOperation,
          services.IMutateFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedService.mutateFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IFeed
       * @returns services.MutateFeedsResponse
       */
      update: async (
        feeds: (resources.IFeed | resources.Feed)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedsResponse> => {
        const ops = this.buildOperations<
          services.FeedOperation,
          resources.IFeed
        >(
          "update",
          feeds,
          // @ts-expect-error Static class type here is fine
          resources.Feed
        );
        const request = this.buildRequest<
          services.FeedOperation,
          services.IMutateFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedService.mutateFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedsResponse
       */
      remove: async (
        feeds: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedsResponse> => {
        const ops = this.buildOperations<services.FeedOperation, string>(
          "remove",
          feeds
        );
        const request = this.buildRequest<
          services.FeedOperation,
          services.IMutateFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedService.mutateFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanAdGroupKeywordService
   */
  public get keywordPlanAdGroupKeywords() {
    const service = this.loadService<services.KeywordPlanAdGroupKeywordService>(
      "KeywordPlanAdGroupKeywordServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlanAdGroupKeywordsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IKeywordPlanAdGroupKeyword
       * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
       */
      create: async (
        keywordPlanAdGroupKeywords: (
          | resources.IKeywordPlanAdGroupKeyword
          | resources.KeywordPlanAdGroupKeyword
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupKeywordOperation,
          resources.IKeywordPlanAdGroupKeyword
        >("create", keywordPlanAdGroupKeywords);
        const request = this.buildRequest<
          services.KeywordPlanAdGroupKeywordOperation,
          services.IMutateKeywordPlanAdGroupKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroupKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlanAdGroupKeyword
       * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
       */
      update: async (
        keywordPlanAdGroupKeywords: (
          | resources.IKeywordPlanAdGroupKeyword
          | resources.KeywordPlanAdGroupKeyword
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupKeywordOperation,
          resources.IKeywordPlanAdGroupKeyword
        >(
          "update",
          keywordPlanAdGroupKeywords,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlanAdGroupKeyword
        );
        const request = this.buildRequest<
          services.KeywordPlanAdGroupKeywordOperation,
          services.IMutateKeywordPlanAdGroupKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroupKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
       */
      remove: async (
        keywordPlanAdGroupKeywords: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupKeywordOperation,
          string
        >("remove", keywordPlanAdGroupKeywords);
        const request = this.buildRequest<
          services.KeywordPlanAdGroupKeywordOperation,
          services.IMutateKeywordPlanAdGroupKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroupKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanAdGroupService
   */
  public get keywordPlanAdGroups() {
    const service = this.loadService<services.KeywordPlanAdGroupService>(
      "KeywordPlanAdGroupServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlanAdGroupsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IKeywordPlanAdGroup
       * @returns services.MutateKeywordPlanAdGroupsResponse
       */
      create: async (
        keywordPlanAdGroups: (
          | resources.IKeywordPlanAdGroup
          | resources.KeywordPlanAdGroup
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupOperation,
          resources.IKeywordPlanAdGroup
        >("create", keywordPlanAdGroups);
        const request = this.buildRequest<
          services.KeywordPlanAdGroupOperation,
          services.IMutateKeywordPlanAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlanAdGroup
       * @returns services.MutateKeywordPlanAdGroupsResponse
       */
      update: async (
        keywordPlanAdGroups: (
          | resources.IKeywordPlanAdGroup
          | resources.KeywordPlanAdGroup
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupOperation,
          resources.IKeywordPlanAdGroup
        >(
          "update",
          keywordPlanAdGroups,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlanAdGroup
        );
        const request = this.buildRequest<
          services.KeywordPlanAdGroupOperation,
          services.IMutateKeywordPlanAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlanAdGroupsResponse
       */
      remove: async (
        keywordPlanAdGroups: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupOperation,
          string
        >("remove", keywordPlanAdGroups);
        const request = this.buildRequest<
          services.KeywordPlanAdGroupOperation,
          services.IMutateKeywordPlanAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanCampaignKeywordService
   */
  public get keywordPlanCampaignKeywords() {
    const service =
      this.loadService<services.KeywordPlanCampaignKeywordService>(
        "KeywordPlanCampaignKeywordServiceClient"
      );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlanCampaignKeywordsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IKeywordPlanCampaignKeyword
       * @returns services.MutateKeywordPlanCampaignKeywordsResponse
       */
      create: async (
        keywordPlanCampaignKeywords: (
          | resources.IKeywordPlanCampaignKeyword
          | resources.KeywordPlanCampaignKeyword
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignKeywordOperation,
          resources.IKeywordPlanCampaignKeyword
        >("create", keywordPlanCampaignKeywords);
        const request = this.buildRequest<
          services.KeywordPlanCampaignKeywordOperation,
          services.IMutateKeywordPlanCampaignKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaignKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlanCampaignKeyword
       * @returns services.MutateKeywordPlanCampaignKeywordsResponse
       */
      update: async (
        keywordPlanCampaignKeywords: (
          | resources.IKeywordPlanCampaignKeyword
          | resources.KeywordPlanCampaignKeyword
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignKeywordOperation,
          resources.IKeywordPlanCampaignKeyword
        >(
          "update",
          keywordPlanCampaignKeywords,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlanCampaignKeyword
        );
        const request = this.buildRequest<
          services.KeywordPlanCampaignKeywordOperation,
          services.IMutateKeywordPlanCampaignKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaignKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlanCampaignKeywordsResponse
       */
      remove: async (
        keywordPlanCampaignKeywords: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignKeywordOperation,
          string
        >("remove", keywordPlanCampaignKeywords);
        const request = this.buildRequest<
          services.KeywordPlanCampaignKeywordOperation,
          services.IMutateKeywordPlanCampaignKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaignKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanCampaignService
   */
  public get keywordPlanCampaigns() {
    const service = this.loadService<services.KeywordPlanCampaignService>(
      "KeywordPlanCampaignServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlanCampaignsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IKeywordPlanCampaign
       * @returns services.MutateKeywordPlanCampaignsResponse
       */
      create: async (
        keywordPlanCampaigns: (
          | resources.IKeywordPlanCampaign
          | resources.KeywordPlanCampaign
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignOperation,
          resources.IKeywordPlanCampaign
        >("create", keywordPlanCampaigns);
        const request = this.buildRequest<
          services.KeywordPlanCampaignOperation,
          services.IMutateKeywordPlanCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlanCampaign
       * @returns services.MutateKeywordPlanCampaignsResponse
       */
      update: async (
        keywordPlanCampaigns: (
          | resources.IKeywordPlanCampaign
          | resources.KeywordPlanCampaign
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignOperation,
          resources.IKeywordPlanCampaign
        >(
          "update",
          keywordPlanCampaigns,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlanCampaign
        );
        const request = this.buildRequest<
          services.KeywordPlanCampaignOperation,
          services.IMutateKeywordPlanCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlanCampaignsResponse
       */
      remove: async (
        keywordPlanCampaigns: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignOperation,
          string
        >("remove", keywordPlanCampaigns);
        const request = this.buildRequest<
          services.KeywordPlanCampaignOperation,
          services.IMutateKeywordPlanCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanService
   */
  public get keywordPlans() {
    const service = this.loadService<services.KeywordPlanService>(
      "KeywordPlanServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlansRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IKeywordPlan
       * @returns services.MutateKeywordPlansResponse
       */
      create: async (
        keywordPlans: (resources.IKeywordPlan | resources.KeywordPlan)[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlansResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanOperation,
          resources.IKeywordPlan
        >("create", keywordPlans);
        const request = this.buildRequest<
          services.KeywordPlanOperation,
          services.IMutateKeywordPlansRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanService.mutateKeywordPlans",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlans(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlan
       * @returns services.MutateKeywordPlansResponse
       */
      update: async (
        keywordPlans: (resources.IKeywordPlan | resources.KeywordPlan)[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlansResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanOperation,
          resources.IKeywordPlan
        >(
          "update",
          keywordPlans,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlan
        );
        const request = this.buildRequest<
          services.KeywordPlanOperation,
          services.IMutateKeywordPlansRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanService.mutateKeywordPlans",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlans(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlansResponse
       */
      remove: async (
        keywordPlans: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlansResponse> => {
        const ops = this.buildOperations<services.KeywordPlanOperation, string>(
          "remove",
          keywordPlans
        );
        const request = this.buildRequest<
          services.KeywordPlanOperation,
          services.IMutateKeywordPlansRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanService.mutateKeywordPlans",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlans(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/LabelService
   */
  public get labels() {
    const service =
      this.loadService<services.LabelService>("LabelServiceClient");
    type MutateOptions = Partial<
      Pick<
        services.IMutateLabelsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ILabel
       * @returns services.MutateLabelsResponse
       */
      create: async (
        labels: (resources.ILabel | resources.Label)[],
        options?: MutateOptions
      ): Promise<services.MutateLabelsResponse> => {
        const ops = this.buildOperations<
          services.LabelOperation,
          resources.ILabel
        >("create", labels);
        const request = this.buildRequest<
          services.LabelOperation,
          services.IMutateLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "LabelService.mutateLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ILabel
       * @returns services.MutateLabelsResponse
       */
      update: async (
        labels: (resources.ILabel | resources.Label)[],
        options?: MutateOptions
      ): Promise<services.MutateLabelsResponse> => {
        const ops = this.buildOperations<
          services.LabelOperation,
          resources.ILabel
        >(
          "update",
          labels,
          // @ts-expect-error Static class type here is fine
          resources.Label
        );
        const request = this.buildRequest<
          services.LabelOperation,
          services.IMutateLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "LabelService.mutateLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateLabelsResponse
       */
      remove: async (
        labels: string[],
        options?: MutateOptions
      ): Promise<services.MutateLabelsResponse> => {
        const ops = this.buildOperations<services.LabelOperation, string>(
          "remove",
          labels
        );
        const request = this.buildRequest<
          services.LabelOperation,
          services.IMutateLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "LabelService.mutateLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/MediaFileService
   */
  public get mediaFiles() {
    const service = this.loadService<services.MediaFileService>(
      "MediaFileServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateMediaFilesRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IMediaFile
       * @returns services.MutateMediaFilesResponse
       */
      create: async (
        mediaFiles: (resources.IMediaFile | resources.MediaFile)[],
        options?: MutateOptions
      ): Promise<services.MutateMediaFilesResponse> => {
        const ops = this.buildOperations<
          services.MediaFileOperation,
          resources.IMediaFile
        >("create", mediaFiles);
        const request = this.buildRequest<
          services.MediaFileOperation,
          services.IMutateMediaFilesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "MediaFileService.mutateMediaFiles",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateMediaFiles(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/RemarketingActionService
   */
  public get remarketingActions() {
    const service = this.loadService<services.RemarketingActionService>(
      "RemarketingActionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateRemarketingActionsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IRemarketingAction
       * @returns services.MutateRemarketingActionsResponse
       */
      create: async (
        remarketingActions: (
          | resources.IRemarketingAction
          | resources.RemarketingAction
        )[],
        options?: MutateOptions
      ): Promise<services.MutateRemarketingActionsResponse> => {
        const ops = this.buildOperations<
          services.RemarketingActionOperation,
          resources.IRemarketingAction
        >("create", remarketingActions);
        const request = this.buildRequest<
          services.RemarketingActionOperation,
          services.IMutateRemarketingActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "RemarketingActionService.mutateRemarketingActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateRemarketingActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IRemarketingAction
       * @returns services.MutateRemarketingActionsResponse
       */
      update: async (
        remarketingActions: (
          | resources.IRemarketingAction
          | resources.RemarketingAction
        )[],
        options?: MutateOptions
      ): Promise<services.MutateRemarketingActionsResponse> => {
        const ops = this.buildOperations<
          services.RemarketingActionOperation,
          resources.IRemarketingAction
        >(
          "update",
          remarketingActions,
          // @ts-expect-error Static class type here is fine
          resources.RemarketingAction
        );
        const request = this.buildRequest<
          services.RemarketingActionOperation,
          services.IMutateRemarketingActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "RemarketingActionService.mutateRemarketingActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateRemarketingActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SharedCriterionService
   */
  public get sharedCriteria() {
    const service = this.loadService<services.SharedCriterionService>(
      "SharedCriterionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateSharedCriteriaRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ISharedCriterion
       * @returns services.MutateSharedCriteriaResponse
       */
      create: async (
        sharedCriteria: (
          | resources.ISharedCriterion
          | resources.SharedCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateSharedCriteriaResponse> => {
        const ops = this.buildOperations<
          services.SharedCriterionOperation,
          resources.ISharedCriterion
        >("create", sharedCriteria);
        const request = this.buildRequest<
          services.SharedCriterionOperation,
          services.IMutateSharedCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedCriterionService.mutateSharedCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateSharedCriteriaResponse
       */
      remove: async (
        sharedCriteria: string[],
        options?: MutateOptions
      ): Promise<services.MutateSharedCriteriaResponse> => {
        const ops = this.buildOperations<
          services.SharedCriterionOperation,
          string
        >("remove", sharedCriteria);
        const request = this.buildRequest<
          services.SharedCriterionOperation,
          services.IMutateSharedCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedCriterionService.mutateSharedCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SharedSetService
   */
  public get sharedSets() {
    const service = this.loadService<services.SharedSetService>(
      "SharedSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateSharedSetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ISharedSet
       * @returns services.MutateSharedSetsResponse
       */
      create: async (
        sharedSets: (resources.ISharedSet | resources.SharedSet)[],
        options?: MutateOptions
      ): Promise<services.MutateSharedSetsResponse> => {
        const ops = this.buildOperations<
          services.SharedSetOperation,
          resources.ISharedSet
        >("create", sharedSets);
        const request = this.buildRequest<
          services.SharedSetOperation,
          services.IMutateSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedSetService.mutateSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ISharedSet
       * @returns services.MutateSharedSetsResponse
       */
      update: async (
        sharedSets: (resources.ISharedSet | resources.SharedSet)[],
        options?: MutateOptions
      ): Promise<services.MutateSharedSetsResponse> => {
        const ops = this.buildOperations<
          services.SharedSetOperation,
          resources.ISharedSet
        >(
          "update",
          sharedSets,
          // @ts-expect-error Static class type here is fine
          resources.SharedSet
        );
        const request = this.buildRequest<
          services.SharedSetOperation,
          services.IMutateSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedSetService.mutateSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateSharedSetsResponse
       */
      remove: async (
        sharedSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateSharedSetsResponse> => {
        const ops = this.buildOperations<services.SharedSetOperation, string>(
          "remove",
          sharedSets
        );
        const request = this.buildRequest<
          services.SharedSetOperation,
          services.IMutateSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedSetService.mutateSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSettingService
   */
  public get smartCampaignSettings() {
    const service = this.loadService<services.SmartCampaignSettingService>(
      "SmartCampaignSettingServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateSmartCampaignSettingsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSettingService#getsmartcampaignstatus
       */
      getSmartCampaignStatus: async (
        request: services.GetSmartCampaignStatusRequest
      ): Promise<services.GetSmartCampaignStatusResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "SmartCampaignSettingService.GetSmartCampaignStatus",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getSmartCampaignStatus(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ISmartCampaignSetting
       * @returns services.MutateSmartCampaignSettingsResponse
       */
      update: async (
        smartCampaignSettings: (
          | resources.ISmartCampaignSetting
          | resources.SmartCampaignSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateSmartCampaignSettingsResponse> => {
        const ops = this.buildOperations<
          services.SmartCampaignSettingOperation,
          resources.ISmartCampaignSetting
        >(
          "update",
          smartCampaignSettings,
          // @ts-expect-error Static class type here is fine
          resources.SmartCampaignSetting
        );
        const request = this.buildRequest<
          services.SmartCampaignSettingOperation,
          services.IMutateSmartCampaignSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SmartCampaignSettingService.mutateSmartCampaignSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSmartCampaignSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/UserListService
   */
  public get userLists() {
    const service = this.loadService<services.UserListService>(
      "UserListServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateUserListsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description create resources of type resources.IUserList
       * @returns services.MutateUserListsResponse
       */
      create: async (
        userLists: (resources.IUserList | resources.UserList)[],
        options?: MutateOptions
      ): Promise<services.MutateUserListsResponse> => {
        const ops = this.buildOperations<
          services.UserListOperation,
          resources.IUserList
        >("create", userLists);
        const request = this.buildRequest<
          services.UserListOperation,
          services.IMutateUserListsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "UserListService.mutateUserLists",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateUserLists(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IUserList
       * @returns services.MutateUserListsResponse
       */
      update: async (
        userLists: (resources.IUserList | resources.UserList)[],
        options?: MutateOptions
      ): Promise<services.MutateUserListsResponse> => {
        const ops = this.buildOperations<
          services.UserListOperation,
          resources.IUserList
        >(
          "update",
          userLists,
          // @ts-expect-error Static class type here is fine
          resources.UserList
        );
        const request = this.buildRequest<
          services.UserListOperation,
          services.IMutateUserListsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "UserListService.mutateUserLists",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateUserLists(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateUserListsResponse
       */
      remove: async (
        userLists: string[],
        options?: MutateOptions
      ): Promise<services.MutateUserListsResponse> => {
        const ops = this.buildOperations<services.UserListOperation, string>(
          "remove",
          userLists
        );
        const request = this.buildRequest<
          services.UserListOperation,
          services.IMutateUserListsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "UserListService.mutateUserLists",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateUserLists(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/BillingSetupService
   */
  public get billingSetups() {
    const service = this.loadService<services.BillingSetupService>(
      "BillingSetupServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @description create resources of type resources.IBillingSetup
       * @returns services.MutateBillingSetupResponse
       */
      create: async (
        billingSetups: (resources.IBillingSetup | resources.BillingSetup)[],
        options?: MutateOptions
      ): Promise<services.MutateBillingSetupResponse> => {
        const ops = this.buildOperations<
          services.BillingSetupOperation,
          resources.IBillingSetup
        >("create", billingSetups);
        const request = this.buildRequest<
          services.BillingSetupOperation,
          services.IMutateBillingSetupRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BillingSetupService.mutateBillingSetup",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBillingSetup(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateBillingSetupResponse
       */
      remove: async (
        billingSetups: string[],
        options?: MutateOptions
      ): Promise<services.MutateBillingSetupResponse> => {
        const ops = this.buildOperations<
          services.BillingSetupOperation,
          string
        >("remove", billingSetups);
        const request = this.buildRequest<
          services.BillingSetupOperation,
          services.IMutateBillingSetupRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BillingSetupService.mutateBillingSetup",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBillingSetup(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionAdjustmentUploadService
   */
  public get conversionAdjustmentUploads() {
    const service =
      this.loadService<services.ConversionAdjustmentUploadService>(
        "ConversionAdjustmentUploadServiceClient"
      );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionAdjustmentUploadService#uploadconversionadjustments
       */
      uploadConversionAdjustments: async (
        request: services.UploadConversionAdjustmentsRequest
      ): Promise<services.UploadConversionAdjustmentsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method:
            "ConversionAdjustmentUploadService.UploadConversionAdjustments",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.uploadConversionAdjustments(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionUploadService
   */
  public get conversionUploads() {
    const service = this.loadService<services.ConversionUploadService>(
      "ConversionUploadServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionUploadService#uploadclickconversions
       */
      uploadClickConversions: async (
        request: services.UploadClickConversionsRequest
      ): Promise<services.UploadClickConversionsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ConversionUploadService.UploadClickConversions",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.uploadClickConversions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ConversionUploadService#uploadcallconversions
       */
      uploadCallConversions: async (
        request: services.UploadCallConversionsRequest
      ): Promise<services.UploadCallConversionsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ConversionUploadService.UploadCallConversions",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.uploadCallConversions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomAudienceService
   */
  public get customAudiences() {
    const service = this.loadService<services.CustomAudienceService>(
      "CustomAudienceServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateCustomAudiencesRequest, "validate_only">
    >;
    return {
      /**
       * @description create resources of type resources.ICustomAudience
       * @returns services.MutateCustomAudiencesResponse
       */
      create: async (
        customAudiences: (
          | resources.ICustomAudience
          | resources.CustomAudience
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomAudiencesResponse> => {
        const ops = this.buildOperations<
          services.CustomAudienceOperation,
          resources.ICustomAudience
        >("create", customAudiences);
        const request = this.buildRequest<
          services.CustomAudienceOperation,
          services.IMutateCustomAudiencesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomAudienceService.mutateCustomAudiences",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomAudiences(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomAudience
       * @returns services.MutateCustomAudiencesResponse
       */
      update: async (
        customAudiences: (
          | resources.ICustomAudience
          | resources.CustomAudience
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomAudiencesResponse> => {
        const ops = this.buildOperations<
          services.CustomAudienceOperation,
          resources.ICustomAudience
        >(
          "update",
          customAudiences,
          // @ts-expect-error Static class type here is fine
          resources.CustomAudience
        );
        const request = this.buildRequest<
          services.CustomAudienceOperation,
          services.IMutateCustomAudiencesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomAudienceService.mutateCustomAudiences",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomAudiences(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomAudiencesResponse
       */
      remove: async (
        customAudiences: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomAudiencesResponse> => {
        const ops = this.buildOperations<
          services.CustomAudienceOperation,
          string
        >("remove", customAudiences);
        const request = this.buildRequest<
          services.CustomAudienceOperation,
          services.IMutateCustomAudiencesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomAudienceService.mutateCustomAudiences",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomAudiences(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomInterestService
   */
  public get customInterests() {
    const service = this.loadService<services.CustomInterestService>(
      "CustomInterestServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateCustomInterestsRequest, "validate_only">
    >;
    return {
      /**
       * @description create resources of type resources.ICustomInterest
       * @returns services.MutateCustomInterestsResponse
       */
      create: async (
        customInterests: (
          | resources.ICustomInterest
          | resources.CustomInterest
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomInterestsResponse> => {
        const ops = this.buildOperations<
          services.CustomInterestOperation,
          resources.ICustomInterest
        >("create", customInterests);
        const request = this.buildRequest<
          services.CustomInterestOperation,
          services.IMutateCustomInterestsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomInterestService.mutateCustomInterests",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomInterests(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomInterest
       * @returns services.MutateCustomInterestsResponse
       */
      update: async (
        customInterests: (
          | resources.ICustomInterest
          | resources.CustomInterest
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomInterestsResponse> => {
        const ops = this.buildOperations<
          services.CustomInterestOperation,
          resources.ICustomInterest
        >(
          "update",
          customInterests,
          // @ts-expect-error Static class type here is fine
          resources.CustomInterest
        );
        const request = this.buildRequest<
          services.CustomInterestOperation,
          services.IMutateCustomInterestsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomInterestService.mutateCustomInterests",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomInterests(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerAssetSetService
   */
  public get customerAssetSets() {
    const service = this.loadService<services.CustomerAssetSetService>(
      "CustomerAssetSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerAssetSetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description create resources of type resources.ICustomerAssetSet
       * @returns services.MutateCustomerAssetSetsResponse
       */
      create: async (
        customerAssetSets: (
          | resources.ICustomerAssetSet
          | resources.CustomerAssetSet
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerAssetSetsResponse> => {
        const ops = this.buildOperations<
          services.CustomerAssetSetOperation,
          resources.ICustomerAssetSet
        >("create", customerAssetSets);
        const request = this.buildRequest<
          services.CustomerAssetSetOperation,
          services.IMutateCustomerAssetSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerAssetSetService.mutateCustomerAssetSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerAssetSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerAssetSetsResponse
       */
      remove: async (
        customerAssetSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerAssetSetsResponse> => {
        const ops = this.buildOperations<
          services.CustomerAssetSetOperation,
          string
        >("remove", customerAssetSets);
        const request = this.buildRequest<
          services.CustomerAssetSetOperation,
          services.IMutateCustomerAssetSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerAssetSetService.mutateCustomerAssetSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerAssetSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerClientLinkService
   */
  public get customerClientLinks() {
    const service = this.loadService<services.CustomerClientLinkService>(
      "CustomerClientLinkServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateCustomerClientLinkRequest, "validate_only">
    >;
    return {
      /**
       * @description create resources of type resources.ICustomerClientLink
       * @returns services.MutateCustomerClientLinkResponse
       */
      create: async (
        customerClientLinks: (
          | resources.ICustomerClientLink
          | resources.CustomerClientLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerClientLinkResponse> => {
        const ops = this.buildOperations<
          services.CustomerClientLinkOperation,
          resources.ICustomerClientLink
        >("create", customerClientLinks);
        const request = this.buildRequest<
          services.CustomerClientLinkOperation,
          services.IMutateCustomerClientLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerClientLinkService.mutateCustomerClientLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerClientLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomerClientLink
       * @returns services.MutateCustomerClientLinkResponse
       */
      update: async (
        customerClientLinks: (
          | resources.ICustomerClientLink
          | resources.CustomerClientLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerClientLinkResponse> => {
        const ops = this.buildOperations<
          services.CustomerClientLinkOperation,
          resources.ICustomerClientLink
        >(
          "update",
          customerClientLinks,
          // @ts-expect-error Static class type here is fine
          resources.CustomerClientLink
        );
        const request = this.buildRequest<
          services.CustomerClientLinkOperation,
          services.IMutateCustomerClientLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerClientLinkService.mutateCustomerClientLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerClientLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerManagerLinkService
   */
  public get customerManagerLinks() {
    const service = this.loadService<services.CustomerManagerLinkService>(
      "CustomerManagerLinkServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateCustomerManagerLinkRequest, "validate_only">
    >;
    return {
      /**
       * @description update resources of type resources.ICustomerManagerLink
       * @returns services.MutateCustomerManagerLinkResponse
       */
      update: async (
        customerManagerLinks: (
          | resources.ICustomerManagerLink
          | resources.CustomerManagerLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerManagerLinkResponse> => {
        const ops = this.buildOperations<
          services.CustomerManagerLinkOperation,
          resources.ICustomerManagerLink
        >(
          "update",
          customerManagerLinks,
          // @ts-expect-error Static class type here is fine
          resources.CustomerManagerLink
        );
        const request = this.buildRequest<
          services.CustomerManagerLinkOperation,
          services.IMutateCustomerManagerLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerManagerLinkService.mutateCustomerManagerLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerManagerLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerManagerLinkService#movemanagerlink
       */
      moveManagerLink: async (
        request: services.MoveManagerLinkRequest
      ): Promise<services.MoveManagerLinkResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "CustomerManagerLinkService.MoveManagerLink",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.moveManagerLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerSkAdNetworkConversionValueSchemaService
   */
  public get customerSkAdNetworkConversionValueSchemas() {
    const service =
      this.loadService<services.CustomerSkAdNetworkConversionValueSchemaService>(
        "CustomerSkAdNetworkConversionValueSchemaServiceClient"
      );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerSkAdNetworkConversionValueSchemaRequest,
        "validate_only"
      >
    >;
    return {
      /**
       * @description update resources of type resources.ICustomerSkAdNetworkConversionValueSchema
       * @returns services.MutateCustomerSkAdNetworkConversionValueSchemaResponse
       */
      update: async (
        customerSkAdNetworkConversionValueSchemas: (
          | resources.ICustomerSkAdNetworkConversionValueSchema
          | resources.CustomerSkAdNetworkConversionValueSchema
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerSkAdNetworkConversionValueSchemaResponse> => {
        const ops = this.buildOperations<
          services.CustomerSkAdNetworkConversionValueSchemaOperation,
          resources.ICustomerSkAdNetworkConversionValueSchema
        >(
          "update",
          customerSkAdNetworkConversionValueSchemas,
          // @ts-expect-error Static class type here is fine
          resources.CustomerSkAdNetworkConversionValueSchema
        );
        const request = this.buildRequest<
          services.CustomerSkAdNetworkConversionValueSchemaOperation,
          services.IMutateCustomerSkAdNetworkConversionValueSchemaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerSkAdNetworkConversionValueSchemaService.mutateCustomerSkAdNetworkConversionValueSchema",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] =
            await service.mutateCustomerSkAdNetworkConversionValueSchema(
              request,
              {
                // @ts-expect-error This arg doesn't exist in the type definitions
                otherArgs: {
                  headers: this.callHeaders,
                },
              }
            );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerUserAccessInvitationService
   */
  public get customerUserAccessInvitations() {
    const service =
      this.loadService<services.CustomerUserAccessInvitationService>(
        "CustomerUserAccessInvitationServiceClient"
      );
    type MutateOptions = never;
    return {
      /**
       * @description create resources of type resources.ICustomerUserAccessInvitation
       * @returns services.MutateCustomerUserAccessInvitationResponse
       */
      create: async (
        customerUserAccessInvitations: (
          | resources.ICustomerUserAccessInvitation
          | resources.CustomerUserAccessInvitation
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerUserAccessInvitationResponse> => {
        const ops = this.buildOperations<
          services.CustomerUserAccessInvitationOperation,
          resources.ICustomerUserAccessInvitation
        >("create", customerUserAccessInvitations);
        const request = this.buildRequest<
          services.CustomerUserAccessInvitationOperation,
          services.IMutateCustomerUserAccessInvitationRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerUserAccessInvitationService.mutateCustomerUserAccessInvitation",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerUserAccessInvitation(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerUserAccessInvitationResponse
       */
      remove: async (
        customerUserAccessInvitations: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerUserAccessInvitationResponse> => {
        const ops = this.buildOperations<
          services.CustomerUserAccessInvitationOperation,
          string
        >("remove", customerUserAccessInvitations);
        const request = this.buildRequest<
          services.CustomerUserAccessInvitationOperation,
          services.IMutateCustomerUserAccessInvitationRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerUserAccessInvitationService.mutateCustomerUserAccessInvitation",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerUserAccessInvitation(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/CustomerUserAccessService
   */
  public get customerUserAccesses() {
    const service = this.loadService<services.CustomerUserAccessService>(
      "CustomerUserAccessServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @description update resources of type resources.ICustomerUserAccess
       * @returns services.MutateCustomerUserAccessResponse
       */
      update: async (
        customerUserAccesses: (
          | resources.ICustomerUserAccess
          | resources.CustomerUserAccess
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerUserAccessResponse> => {
        const ops = this.buildOperations<
          services.CustomerUserAccessOperation,
          resources.ICustomerUserAccess
        >(
          "update",
          customerUserAccesses,
          // @ts-expect-error Static class type here is fine
          resources.CustomerUserAccess
        );
        const request = this.buildRequest<
          services.CustomerUserAccessOperation,
          services.IMutateCustomerUserAccessRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerUserAccessService.mutateCustomerUserAccess",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerUserAccess(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerUserAccessResponse
       */
      remove: async (
        customerUserAccesses: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerUserAccessResponse> => {
        const ops = this.buildOperations<
          services.CustomerUserAccessOperation,
          string
        >("remove", customerUserAccesses);
        const request = this.buildRequest<
          services.CustomerUserAccessOperation,
          services.IMutateCustomerUserAccessRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerUserAccessService.mutateCustomerUserAccess",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerUserAccess(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/GeoTargetConstantService
   */
  public get geoTargetConstants() {
    const service = this.loadService<services.GeoTargetConstantService>(
      "GeoTargetConstantServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/GeoTargetConstantService#suggestgeotargetconstants
       */
      suggestGeoTargetConstants: async (
        request: services.SuggestGeoTargetConstantsRequest
      ): Promise<services.SuggestGeoTargetConstantsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "GeoTargetConstantService.SuggestGeoTargetConstants",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.suggestGeoTargetConstants(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/InvoiceService
   */
  public get invoices() {
    const service = this.loadService<services.InvoiceService>(
      "InvoiceServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/InvoiceService#listinvoices
       */
      listInvoices: async (
        request: services.ListInvoicesRequest
      ): Promise<services.ListInvoicesResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "InvoiceService.ListInvoices",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listInvoices(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService
   */
  public get keywordPlanIdeas() {
    const service = this.loadService<services.KeywordPlanIdeaService>(
      "KeywordPlanIdeaServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService#generatekeywordideas
       */
      generateKeywordIdeas: async (
        request: services.GenerateKeywordIdeasRequest
      ): Promise<services.GenerateKeywordIdeaResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanIdeaService.GenerateKeywordIdeas",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateKeywordIdeas(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService#generatekeywordhistoricalmetrics
       */
      generateKeywordHistoricalMetrics: async (
        request: services.GenerateKeywordHistoricalMetricsRequest
      ): Promise<services.GenerateKeywordHistoricalMetricsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateKeywordHistoricalMetrics(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService#generateadgroupthemes
       */
      generateAdGroupThemes: async (
        request: services.GenerateAdGroupThemesRequest
      ): Promise<services.GenerateAdGroupThemesResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanIdeaService.GenerateAdGroupThemes",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateAdGroupThemes(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordPlanIdeaService#generatekeywordforecastmetrics
       */
      generateKeywordForecastMetrics: async (
        request: services.GenerateKeywordForecastMetricsRequest
      ): Promise<services.GenerateKeywordForecastMetricsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanIdeaService.GenerateKeywordForecastMetrics",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateKeywordForecastMetrics(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordThemeConstantService
   */
  public get keywordThemeConstants() {
    const service = this.loadService<services.KeywordThemeConstantService>(
      "KeywordThemeConstantServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/KeywordThemeConstantService#suggestkeywordthemeconstants
       */
      suggestKeywordThemeConstants: async (
        request: services.SuggestKeywordThemeConstantsRequest
      ): Promise<services.SuggestKeywordThemeConstantsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "KeywordThemeConstantService.SuggestKeywordThemeConstants",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.suggestKeywordThemeConstants(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/MerchantCenterLinkService
   */
  public get merchantCenterLinks() {
    const service = this.loadService<services.MerchantCenterLinkService>(
      "MerchantCenterLinkServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateMerchantCenterLinkRequest, "validate_only">
    >;
    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/MerchantCenterLinkService#listmerchantcenterlinks
       */
      listMerchantCenterLinks: async (
        request: services.ListMerchantCenterLinksRequest
      ): Promise<services.ListMerchantCenterLinksResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "MerchantCenterLinkService.ListMerchantCenterLinks",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listMerchantCenterLinks(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/MerchantCenterLinkService#getmerchantcenterlink
       */
      getMerchantCenterLink: async (
        request: services.GetMerchantCenterLinkRequest
      ): Promise<resources.MerchantCenterLink> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "MerchantCenterLinkService.GetMerchantCenterLink",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getMerchantCenterLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IMerchantCenterLink
       * @returns services.MutateMerchantCenterLinkResponse
       */
      update: async (
        merchantCenterLinks: (
          | resources.IMerchantCenterLink
          | resources.MerchantCenterLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateMerchantCenterLinkResponse> => {
        const ops = this.buildOperations<
          services.MerchantCenterLinkOperation,
          resources.IMerchantCenterLink
        >(
          "update",
          merchantCenterLinks,
          // @ts-expect-error Static class type here is fine
          resources.MerchantCenterLink
        );
        const request = this.buildRequest<
          services.MerchantCenterLinkOperation,
          services.IMutateMerchantCenterLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "MerchantCenterLinkService.mutateMerchantCenterLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateMerchantCenterLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateMerchantCenterLinkResponse
       */
      remove: async (
        merchantCenterLinks: string[],
        options?: MutateOptions
      ): Promise<services.MutateMerchantCenterLinkResponse> => {
        const ops = this.buildOperations<
          services.MerchantCenterLinkOperation,
          string
        >("remove", merchantCenterLinks);
        const request = this.buildRequest<
          services.MerchantCenterLinkOperation,
          services.IMutateMerchantCenterLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "MerchantCenterLinkService.mutateMerchantCenterLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateMerchantCenterLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/OfflineUserDataJobService
   */
  public get offlineUserDataJobs() {
    const service = this.loadService<services.OfflineUserDataJobService>(
      "OfflineUserDataJobServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/OfflineUserDataJobService#createofflineuserdatajob
       */
      createOfflineUserDataJob: async (
        request: services.CreateOfflineUserDataJobRequest
      ): Promise<services.CreateOfflineUserDataJobResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "OfflineUserDataJobService.CreateOfflineUserDataJob",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.createOfflineUserDataJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/OfflineUserDataJobService#addofflineuserdatajoboperations
       */
      addOfflineUserDataJobOperations: async (
        request: services.AddOfflineUserDataJobOperationsRequest
      ): Promise<services.AddOfflineUserDataJobOperationsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "OfflineUserDataJobService.AddOfflineUserDataJobOperations",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.addOfflineUserDataJobOperations(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/OfflineUserDataJobService#runofflineuserdatajob
       */
      runOfflineUserDataJob: async (
        request: services.RunOfflineUserDataJobRequest
      ): Promise<longrunning.Operation> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "OfflineUserDataJobService.RunOfflineUserDataJob",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.runOfflineUserDataJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/PaymentsAccountService
   */
  public get paymentsAccounts() {
    const service = this.loadService<services.PaymentsAccountService>(
      "PaymentsAccountServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/PaymentsAccountService#listpaymentsaccounts
       */
      listPaymentsAccounts: async (
        request: services.ListPaymentsAccountsRequest
      ): Promise<services.ListPaymentsAccountsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "PaymentsAccountService.ListPaymentsAccounts",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listPaymentsAccounts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ProductLinkService
   */
  public get productLinks() {
    const service = this.loadService<services.ProductLinkService>(
      "ProductLinkServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ProductLinkService#createproductlink
       */
      createProductLink: async (
        request: services.CreateProductLinkRequest
      ): Promise<services.CreateProductLinkResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ProductLinkService.CreateProductLink",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.createProductLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ProductLinkService#removeproductlink
       */
      removeProductLink: async (
        request: services.RemoveProductLinkRequest
      ): Promise<services.RemoveProductLinkResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ProductLinkService.RemoveProductLink",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.removeProductLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ReachPlanService
   */
  public get reachPlans() {
    const service = this.loadService<services.ReachPlanService>(
      "ReachPlanServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ReachPlanService#listplannablelocations
       */
      listPlannableLocations: async (
        request: services.ListPlannableLocationsRequest
      ): Promise<services.ListPlannableLocationsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ReachPlanService.ListPlannableLocations",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listPlannableLocations(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ReachPlanService#listplannableproducts
       */
      listPlannableProducts: async (
        request: services.ListPlannableProductsRequest
      ): Promise<services.ListPlannableProductsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ReachPlanService.ListPlannableProducts",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listPlannableProducts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ReachPlanService#generatereachforecast
       */
      generateReachForecast: async (
        request: services.GenerateReachForecastRequest
      ): Promise<services.GenerateReachForecastResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ReachPlanService.GenerateReachForecast",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateReachForecast(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/RecommendationService
   */
  public get recommendations() {
    const service = this.loadService<services.RecommendationService>(
      "RecommendationServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/RecommendationService#applyrecommendation
       */
      applyRecommendation: async (
        request: services.ApplyRecommendationRequest
      ): Promise<services.ApplyRecommendationResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "RecommendationService.ApplyRecommendation",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.applyRecommendation(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/RecommendationService#dismissrecommendation
       */
      dismissRecommendation: async (
        request: services.DismissRecommendationRequest
      ): Promise<services.DismissRecommendationResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "RecommendationService.DismissRecommendation",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.dismissRecommendation(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSuggestService
   */
  public get smartCampaignSuggests() {
    const service = this.loadService<services.SmartCampaignSuggestService>(
      "SmartCampaignSuggestServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSuggestService#suggestsmartcampaignbudgetoptions
       */
      suggestSmartCampaignBudgetOptions: async (
        request: services.SuggestSmartCampaignBudgetOptionsRequest
      ): Promise<services.SuggestSmartCampaignBudgetOptionsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method:
            "SmartCampaignSuggestService.SuggestSmartCampaignBudgetOptions",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.suggestSmartCampaignBudgetOptions(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSuggestService#suggestsmartcampaignad
       */
      suggestSmartCampaignAd: async (
        request: services.SuggestSmartCampaignAdRequest
      ): Promise<services.SuggestSmartCampaignAdResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "SmartCampaignSuggestService.SuggestSmartCampaignAd",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.suggestSmartCampaignAd(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/SmartCampaignSuggestService#suggestkeywordthemes
       */
      suggestKeywordThemes: async (
        request: services.SuggestKeywordThemesRequest
      ): Promise<services.SuggestKeywordThemesResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "SmartCampaignSuggestService.SuggestKeywordThemes",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.suggestKeywordThemes(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ThirdPartyAppAnalyticsLinkService
   */
  public get thirdPartyAppAnalyticsLinks() {
    const service =
      this.loadService<services.ThirdPartyAppAnalyticsLinkService>(
        "ThirdPartyAppAnalyticsLinkServiceClient"
      );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/ThirdPartyAppAnalyticsLinkService#regenerateshareablelinkid
       */
      regenerateShareableLinkId: async (
        request: services.RegenerateShareableLinkIdRequest
      ): Promise<services.RegenerateShareableLinkIdResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "ThirdPartyAppAnalyticsLinkService.RegenerateShareableLinkId",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.regenerateShareableLinkId(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/TravelAssetSuggestionService
   */
  public get travelAssetSuggestions() {
    const service = this.loadService<services.TravelAssetSuggestionService>(
      "TravelAssetSuggestionServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/TravelAssetSuggestionService#suggesttravelassets
       */
      suggestTravelAssets: async (
        request: services.SuggestTravelAssetsRequest
      ): Promise<services.SuggestTravelAssetsResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "TravelAssetSuggestionService.SuggestTravelAssets",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.suggestTravelAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v14/UserDataService
   */
  public get userData() {
    const service = this.loadService<services.UserDataService>(
      "UserDataServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v14/UserDataService#uploaduserdata
       */
      uploadUserData: async (
        request: services.UploadUserDataRequest
      ): Promise<services.UploadUserDataResponse> => {
        const baseHookArguments: BaseServiceHookArgs = {
          credentials: this.credentials,
          method: "UserDataService.UploadUserData",
          requestOptions: request,
        };
        if (this.hooks.onServiceStart) {
          const serviceCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onServiceStart({
            ...baseHookArguments,
            cancel: (res) => {
              serviceCancellation.cancelled = true;
              serviceCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (serviceCancellation.cancelled) {
            return serviceCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.uploadUserData(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onServiceEnd) {
            const serviceResolution: HookedResolution = { resolved: false };
            await this.hooks.onServiceEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                serviceResolution.resolved = true;
                serviceResolution.res = res;
              },
            });
            if (serviceResolution.resolved) {
              return serviceResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err as Error);
          if (this.hooks.onServiceError) {
            await this.hooks.onServiceError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }
}
