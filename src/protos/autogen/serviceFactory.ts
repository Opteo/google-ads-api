/* Autogenerated File! Do Not Edit */

import { ClientOptions } from "../../client";
import { CustomerOptions } from "../../types";
import { Service } from "../../service";
import { resources, services, protobuf, longrunning } from "../index";
import {
  BaseMutationHookArgs,
  HookedCancellation,
  HookedResolution,
  Hooks,
} from "../../hooks";

export default class ServiceFactory extends Service {
  constructor(
    clientOptions: ClientOptions,
    customerOptions: CustomerOptions,
    hooks?: Hooks,
    timeout = 3600000 // 1 hour
  ) {
    super(clientOptions, customerOptions, hooks ?? {}, timeout);
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AccountBudgetProposalService
   */
  public get accountBudgetProposals() {
    const service = this.loadService<services.AccountBudgetProposalService>(
      "AccountBudgetProposalServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateAccountBudgetProposalRequest, "validate_only">
    >;
    return {
      /**
       * @description Retrieve a resources.AccountBudgetProposal in full detail
       * @warning Don't use get in production!
       * @returns resources.AccountBudgetProposal
       */
      get: async (
        resourceName: string
      ): Promise<resources.AccountBudgetProposal> => {
        const request = new services.GetAccountBudgetProposalRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAccountBudgetProposal(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAccountBudgetProposal
       * @returns services.MutateAccountBudgetProposalResponse
       */
      create: async (
        accountBudgetProposals: (
          | resources.IAccountBudgetProposal
          | resources.AccountBudgetProposal
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAccountBudgetProposalResponse> => {
        const ops = this.buildOperations<
          services.AccountBudgetProposalOperation,
          resources.IAccountBudgetProposal
        >("create", accountBudgetProposals);
        const request = this.buildRequest<
          services.AccountBudgetProposalOperation,
          services.IMutateAccountBudgetProposalRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AccountBudgetProposalService.mutateAccountBudgetProposal",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAccountBudgetProposal(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAccountBudgetProposalResponse
       */
      remove: async (
        accountBudgetProposals: string[],
        options?: MutateOptions
      ): Promise<services.MutateAccountBudgetProposalResponse> => {
        const ops = this.buildOperations<
          services.AccountBudgetProposalOperation,
          string
        >("remove", accountBudgetProposals);
        const request = this.buildRequest<
          services.AccountBudgetProposalOperation,
          services.IMutateAccountBudgetProposalRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AccountBudgetProposalService.mutateAccountBudgetProposal",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAccountBudgetProposal(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AccountBudgetService
   */
  public get accountBudgets() {
    const service = this.loadService<services.AccountBudgetService>(
      "AccountBudgetServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.AccountBudget in full detail
       * @warning Don't use get in production!
       * @returns resources.AccountBudget
       */
      get: async (resourceName: string): Promise<resources.AccountBudget> => {
        const request = new services.GetAccountBudgetRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAccountBudget(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AccountLinkService
   */
  public get accountLinks() {
    const service = this.loadService<services.AccountLinkService>(
      "AccountLinkServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAccountLinkRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AccountLink in full detail
       * @warning Don't use get in production!
       * @returns resources.AccountLink
       */
      get: async (resourceName: string): Promise<resources.AccountLink> => {
        const request = new services.GetAccountLinkRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAccountLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AccountLinkService#createaccountlink
       */
      createAccountLink: async (
        request: services.CreateAccountLinkRequest
      ): Promise<services.CreateAccountLinkResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.createAccountLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description update resources of type resources.IAccountLink
       * @returns services.MutateAccountLinkResponse
       */
      update: async (
        accountLinks: (resources.IAccountLink | resources.AccountLink)[],
        options?: MutateOptions
      ): Promise<services.MutateAccountLinkResponse> => {
        const ops = this.buildOperations<
          services.AccountLinkOperation,
          resources.IAccountLink
        >(
          "update",
          accountLinks,
          // @ts-expect-error Static class type here is fine
          resources.AccountLink
        );
        const request = this.buildRequest<
          services.AccountLinkOperation,
          services.IMutateAccountLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AccountLinkService.mutateAccountLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAccountLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAccountLinkResponse
       */
      remove: async (
        accountLinks: string[],
        options?: MutateOptions
      ): Promise<services.MutateAccountLinkResponse> => {
        const ops = this.buildOperations<services.AccountLinkOperation, string>(
          "remove",
          accountLinks
        );
        const request = this.buildRequest<
          services.AccountLinkOperation,
          services.IMutateAccountLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AccountLinkService.mutateAccountLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAccountLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupAdAssetViewService
   */
  public get adGroupAdAssetViews() {
    const service = this.loadService<services.AdGroupAdAssetViewService>(
      "AdGroupAdAssetViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.AdGroupAdAssetView in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupAdAssetView
       */
      get: async (
        resourceName: string
      ): Promise<resources.AdGroupAdAssetView> => {
        const request = new services.GetAdGroupAdAssetViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupAdAssetView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupAdLabelService
   */
  public get adGroupAdLabels() {
    const service = this.loadService<services.AdGroupAdLabelService>(
      "AdGroupAdLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupAdLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdGroupAdLabel in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupAdLabel
       */
      get: async (resourceName: string): Promise<resources.AdGroupAdLabel> => {
        const request = new services.GetAdGroupAdLabelRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupAdLabel(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdGroupAdLabel
       * @returns services.MutateAdGroupAdLabelsResponse
       */
      create: async (
        adGroupAdLabels: (
          | resources.IAdGroupAdLabel
          | resources.AdGroupAdLabel
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAdLabelOperation,
          resources.IAdGroupAdLabel
        >("create", adGroupAdLabels);
        const request = this.buildRequest<
          services.AdGroupAdLabelOperation,
          services.IMutateAdGroupAdLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdLabelService.mutateAdGroupAdLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAdLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupAdLabelsResponse
       */
      remove: async (
        adGroupAdLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAdLabelOperation,
          string
        >("remove", adGroupAdLabels);
        const request = this.buildRequest<
          services.AdGroupAdLabelOperation,
          services.IMutateAdGroupAdLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdLabelService.mutateAdGroupAdLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAdLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupAdService
   */
  public get adGroupAds() {
    const service = this.loadService<services.AdGroupAdService>(
      "AdGroupAdServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupAdsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdGroupAd in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupAd
       */
      get: async (resourceName: string): Promise<resources.AdGroupAd> => {
        const request = new services.GetAdGroupAdRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupAd(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdGroupAd
       * @returns services.MutateAdGroupAdsResponse
       */
      create: async (
        adGroupAds: (resources.IAdGroupAd | resources.AdGroupAd)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAdOperation,
          resources.IAdGroupAd
        >("create", adGroupAds);
        const request = this.buildRequest<
          services.AdGroupAdOperation,
          services.IMutateAdGroupAdsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdService.mutateAdGroupAds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupAd
       * @returns services.MutateAdGroupAdsResponse
       */
      update: async (
        adGroupAds: (resources.IAdGroupAd | resources.AdGroupAd)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupAdOperation,
          resources.IAdGroupAd
        >(
          "update",
          adGroupAds,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupAd
        );
        const request = this.buildRequest<
          services.AdGroupAdOperation,
          services.IMutateAdGroupAdsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdService.mutateAdGroupAds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupAdsResponse
       */
      remove: async (
        adGroupAds: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupAdsResponse> => {
        const ops = this.buildOperations<services.AdGroupAdOperation, string>(
          "remove",
          adGroupAds
        );
        const request = this.buildRequest<
          services.AdGroupAdOperation,
          services.IMutateAdGroupAdsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupAdService.mutateAdGroupAds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupAds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupAudienceViewService
   */
  public get adGroupAudienceViews() {
    const service = this.loadService<services.AdGroupAudienceViewService>(
      "AdGroupAudienceViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.AdGroupAudienceView in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupAudienceView
       */
      get: async (
        resourceName: string
      ): Promise<resources.AdGroupAudienceView> => {
        const request = new services.GetAdGroupAudienceViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupAudienceView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupBidModifierService
   */
  public get adGroupBidModifiers() {
    const service = this.loadService<services.AdGroupBidModifierService>(
      "AdGroupBidModifierServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupBidModifiersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdGroupBidModifier in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupBidModifier
       */
      get: async (
        resourceName: string
      ): Promise<resources.AdGroupBidModifier> => {
        const request = new services.GetAdGroupBidModifierRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupBidModifier(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdGroupBidModifier
       * @returns services.MutateAdGroupBidModifiersResponse
       */
      create: async (
        adGroupBidModifiers: (
          | resources.IAdGroupBidModifier
          | resources.AdGroupBidModifier
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupBidModifierOperation,
          resources.IAdGroupBidModifier
        >("create", adGroupBidModifiers);
        const request = this.buildRequest<
          services.AdGroupBidModifierOperation,
          services.IMutateAdGroupBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupBidModifier
       * @returns services.MutateAdGroupBidModifiersResponse
       */
      update: async (
        adGroupBidModifiers: (
          | resources.IAdGroupBidModifier
          | resources.AdGroupBidModifier
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupBidModifierOperation,
          resources.IAdGroupBidModifier
        >(
          "update",
          adGroupBidModifiers,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupBidModifier
        );
        const request = this.buildRequest<
          services.AdGroupBidModifierOperation,
          services.IMutateAdGroupBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupBidModifiersResponse
       */
      remove: async (
        adGroupBidModifiers: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.AdGroupBidModifierOperation,
          string
        >("remove", adGroupBidModifiers);
        const request = this.buildRequest<
          services.AdGroupBidModifierOperation,
          services.IMutateAdGroupBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupCriterionLabelService
   */
  public get adGroupCriterionLabels() {
    const service = this.loadService<services.AdGroupCriterionLabelService>(
      "AdGroupCriterionLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupCriterionLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdGroupCriterionLabel in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupCriterionLabel
       */
      get: async (
        resourceName: string
      ): Promise<resources.AdGroupCriterionLabel> => {
        const request = new services.GetAdGroupCriterionLabelRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupCriterionLabel(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdGroupCriterionLabel
       * @returns services.MutateAdGroupCriterionLabelsResponse
       */
      create: async (
        adGroupCriterionLabels: (
          | resources.IAdGroupCriterionLabel
          | resources.AdGroupCriterionLabel
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriterionLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionLabelOperation,
          resources.IAdGroupCriterionLabel
        >("create", adGroupCriterionLabels);
        const request = this.buildRequest<
          services.AdGroupCriterionLabelOperation,
          services.IMutateAdGroupCriterionLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionLabelService.mutateAdGroupCriterionLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriterionLabels(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupCriterionLabelsResponse
       */
      remove: async (
        adGroupCriterionLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriterionLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionLabelOperation,
          string
        >("remove", adGroupCriterionLabels);
        const request = this.buildRequest<
          services.AdGroupCriterionLabelOperation,
          services.IMutateAdGroupCriterionLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionLabelService.mutateAdGroupCriterionLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriterionLabels(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupCriterionService
   */
  public get adGroupCriteria() {
    const service = this.loadService<services.AdGroupCriterionService>(
      "AdGroupCriterionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupCriteriaRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdGroupCriterion in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupCriterion
       */
      get: async (
        resourceName: string
      ): Promise<resources.AdGroupCriterion> => {
        const request = new services.GetAdGroupCriterionRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupCriterion(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdGroupCriterion
       * @returns services.MutateAdGroupCriteriaResponse
       */
      create: async (
        adGroupCriteria: (
          | resources.IAdGroupCriterion
          | resources.AdGroupCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriteriaResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionOperation,
          resources.IAdGroupCriterion
        >("create", adGroupCriteria);
        const request = this.buildRequest<
          services.AdGroupCriterionOperation,
          services.IMutateAdGroupCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionService.mutateAdGroupCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupCriterion
       * @returns services.MutateAdGroupCriteriaResponse
       */
      update: async (
        adGroupCriteria: (
          | resources.IAdGroupCriterion
          | resources.AdGroupCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriteriaResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionOperation,
          resources.IAdGroupCriterion
        >(
          "update",
          adGroupCriteria,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupCriterion
        );
        const request = this.buildRequest<
          services.AdGroupCriterionOperation,
          services.IMutateAdGroupCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionService.mutateAdGroupCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupCriteriaResponse
       */
      remove: async (
        adGroupCriteria: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupCriteriaResponse> => {
        const ops = this.buildOperations<
          services.AdGroupCriterionOperation,
          string
        >("remove", adGroupCriteria);
        const request = this.buildRequest<
          services.AdGroupCriterionOperation,
          services.IMutateAdGroupCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupCriterionService.mutateAdGroupCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupCriterionSimulationService
   */
  public get adGroupCriterionSimulations() {
    const service = this.loadService<services.AdGroupCriterionSimulationService>(
      "AdGroupCriterionSimulationServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.AdGroupCriterionSimulation in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupCriterionSimulation
       */
      get: async (
        resourceName: string
      ): Promise<resources.AdGroupCriterionSimulation> => {
        const request = new services.GetAdGroupCriterionSimulationRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupCriterionSimulation(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupExtensionSettingService
   */
  public get adGroupExtensionSettings() {
    const service = this.loadService<services.AdGroupExtensionSettingService>(
      "AdGroupExtensionSettingServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupExtensionSettingsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdGroupExtensionSetting in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupExtensionSetting
       */
      get: async (
        resourceName: string
      ): Promise<resources.AdGroupExtensionSetting> => {
        const request = new services.GetAdGroupExtensionSettingRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupExtensionSetting(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdGroupExtensionSetting
       * @returns services.MutateAdGroupExtensionSettingsResponse
       */
      create: async (
        adGroupExtensionSettings: (
          | resources.IAdGroupExtensionSetting
          | resources.AdGroupExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupExtensionSettingOperation,
          resources.IAdGroupExtensionSetting
        >("create", adGroupExtensionSettings);
        const request = this.buildRequest<
          services.AdGroupExtensionSettingOperation,
          services.IMutateAdGroupExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AdGroupExtensionSettingService.mutateAdGroupExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupExtensionSetting
       * @returns services.MutateAdGroupExtensionSettingsResponse
       */
      update: async (
        adGroupExtensionSettings: (
          | resources.IAdGroupExtensionSetting
          | resources.AdGroupExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupExtensionSettingOperation,
          resources.IAdGroupExtensionSetting
        >(
          "update",
          adGroupExtensionSettings,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupExtensionSetting
        );
        const request = this.buildRequest<
          services.AdGroupExtensionSettingOperation,
          services.IMutateAdGroupExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AdGroupExtensionSettingService.mutateAdGroupExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupExtensionSettingsResponse
       */
      remove: async (
        adGroupExtensionSettings: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupExtensionSettingOperation,
          string
        >("remove", adGroupExtensionSettings);
        const request = this.buildRequest<
          services.AdGroupExtensionSettingOperation,
          services.IMutateAdGroupExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "AdGroupExtensionSettingService.mutateAdGroupExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupFeedService
   */
  public get adGroupFeeds() {
    const service = this.loadService<services.AdGroupFeedService>(
      "AdGroupFeedServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupFeedsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdGroupFeed in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupFeed
       */
      get: async (resourceName: string): Promise<resources.AdGroupFeed> => {
        const request = new services.GetAdGroupFeedRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupFeed(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdGroupFeed
       * @returns services.MutateAdGroupFeedsResponse
       */
      create: async (
        adGroupFeeds: (resources.IAdGroupFeed | resources.AdGroupFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupFeedsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupFeedOperation,
          resources.IAdGroupFeed
        >("create", adGroupFeeds);
        const request = this.buildRequest<
          services.AdGroupFeedOperation,
          services.IMutateAdGroupFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupFeedService.mutateAdGroupFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroupFeed
       * @returns services.MutateAdGroupFeedsResponse
       */
      update: async (
        adGroupFeeds: (resources.IAdGroupFeed | resources.AdGroupFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupFeedsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupFeedOperation,
          resources.IAdGroupFeed
        >(
          "update",
          adGroupFeeds,
          // @ts-expect-error Static class type here is fine
          resources.AdGroupFeed
        );
        const request = this.buildRequest<
          services.AdGroupFeedOperation,
          services.IMutateAdGroupFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupFeedService.mutateAdGroupFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupFeedsResponse
       */
      remove: async (
        adGroupFeeds: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupFeedsResponse> => {
        const ops = this.buildOperations<services.AdGroupFeedOperation, string>(
          "remove",
          adGroupFeeds
        );
        const request = this.buildRequest<
          services.AdGroupFeedOperation,
          services.IMutateAdGroupFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupFeedService.mutateAdGroupFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupLabelService
   */
  public get adGroupLabels() {
    const service = this.loadService<services.AdGroupLabelService>(
      "AdGroupLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdGroupLabel in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupLabel
       */
      get: async (resourceName: string): Promise<resources.AdGroupLabel> => {
        const request = new services.GetAdGroupLabelRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupLabel(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdGroupLabel
       * @returns services.MutateAdGroupLabelsResponse
       */
      create: async (
        adGroupLabels: (resources.IAdGroupLabel | resources.AdGroupLabel)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupLabelOperation,
          resources.IAdGroupLabel
        >("create", adGroupLabels);
        const request = this.buildRequest<
          services.AdGroupLabelOperation,
          services.IMutateAdGroupLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupLabelService.mutateAdGroupLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupLabelsResponse
       */
      remove: async (
        adGroupLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupLabelsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupLabelOperation,
          string
        >("remove", adGroupLabels);
        const request = this.buildRequest<
          services.AdGroupLabelOperation,
          services.IMutateAdGroupLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupLabelService.mutateAdGroupLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroupLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupService
   */
  public get adGroups() {
    const service = this.loadService<services.AdGroupService>(
      "AdGroupServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdGroupsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdGroup in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroup
       */
      get: async (resourceName: string): Promise<resources.AdGroup> => {
        const request = new services.GetAdGroupRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroup(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdGroup
       * @returns services.MutateAdGroupsResponse
       */
      create: async (
        adGroups: (resources.IAdGroup | resources.AdGroup)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupOperation,
          resources.IAdGroup
        >("create", adGroups);
        const request = this.buildRequest<
          services.AdGroupOperation,
          services.IMutateAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupService.mutateAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdGroup
       * @returns services.MutateAdGroupsResponse
       */
      update: async (
        adGroups: (resources.IAdGroup | resources.AdGroup)[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.AdGroupOperation,
          resources.IAdGroup
        >(
          "update",
          adGroups,
          // @ts-expect-error Static class type here is fine
          resources.AdGroup
        );
        const request = this.buildRequest<
          services.AdGroupOperation,
          services.IMutateAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupService.mutateAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdGroupsResponse
       */
      remove: async (
        adGroups: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdGroupsResponse> => {
        const ops = this.buildOperations<services.AdGroupOperation, string>(
          "remove",
          adGroups
        );
        const request = this.buildRequest<
          services.AdGroupOperation,
          services.IMutateAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdGroupService.mutateAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdGroupSimulationService
   */
  public get adGroupSimulations() {
    const service = this.loadService<services.AdGroupSimulationService>(
      "AdGroupSimulationServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.AdGroupSimulation in full detail
       * @warning Don't use get in production!
       * @returns resources.AdGroupSimulation
       */
      get: async (
        resourceName: string
      ): Promise<resources.AdGroupSimulation> => {
        const request = new services.GetAdGroupSimulationRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdGroupSimulation(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdParameterService
   */
  public get adParameters() {
    const service = this.loadService<services.AdParameterService>(
      "AdParameterServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateAdParametersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.AdParameter in full detail
       * @warning Don't use get in production!
       * @returns resources.AdParameter
       */
      get: async (resourceName: string): Promise<resources.AdParameter> => {
        const request = new services.GetAdParameterRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdParameter(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAdParameter
       * @returns services.MutateAdParametersResponse
       */
      create: async (
        adParameters: (resources.IAdParameter | resources.AdParameter)[],
        options?: MutateOptions
      ): Promise<services.MutateAdParametersResponse> => {
        const ops = this.buildOperations<
          services.AdParameterOperation,
          resources.IAdParameter
        >("create", adParameters);
        const request = this.buildRequest<
          services.AdParameterOperation,
          services.IMutateAdParametersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdParameterService.mutateAdParameters",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdParameters(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAdParameter
       * @returns services.MutateAdParametersResponse
       */
      update: async (
        adParameters: (resources.IAdParameter | resources.AdParameter)[],
        options?: MutateOptions
      ): Promise<services.MutateAdParametersResponse> => {
        const ops = this.buildOperations<
          services.AdParameterOperation,
          resources.IAdParameter
        >(
          "update",
          adParameters,
          // @ts-expect-error Static class type here is fine
          resources.AdParameter
        );
        const request = this.buildRequest<
          services.AdParameterOperation,
          services.IMutateAdParametersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdParameterService.mutateAdParameters",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdParameters(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateAdParametersResponse
       */
      remove: async (
        adParameters: string[],
        options?: MutateOptions
      ): Promise<services.MutateAdParametersResponse> => {
        const ops = this.buildOperations<services.AdParameterOperation, string>(
          "remove",
          adParameters
        );
        const request = this.buildRequest<
          services.AdParameterOperation,
          services.IMutateAdParametersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdParameterService.mutateAdParameters",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAdParameters(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdScheduleViewService
   */
  public get adScheduleViews() {
    const service = this.loadService<services.AdScheduleViewService>(
      "AdScheduleViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.AdScheduleView in full detail
       * @warning Don't use get in production!
       * @returns resources.AdScheduleView
       */
      get: async (resourceName: string): Promise<resources.AdScheduleView> => {
        const request = new services.GetAdScheduleViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAdScheduleView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AdService
   */
  public get ads() {
    const service = this.loadService<services.AdService>("AdServiceClient");
    type MutateOptions = Partial<
      Pick<services.IMutateAdsRequest, "response_content_type">
    >;
    return {
      /**
       * @description Retrieve a resources.Ad in full detail
       * @warning Don't use get in production!
       * @returns resources.Ad
       */
      get: async (resourceName: string): Promise<resources.Ad> => {
        const request = new services.GetAdRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAd(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description update resources of type resources.IAd
       * @returns services.MutateAdsResponse
       */
      update: async (
        ads: (resources.IAd | resources.Ad)[],
        options?: MutateOptions
      ): Promise<services.MutateAdsResponse> => {
        const ops = this.buildOperations<services.AdOperation, resources.IAd>(
          "update",
          ads,
          // @ts-expect-error Static class type here is fine
          resources.Ad
        );
        const request = this.buildRequest<
          services.AdOperation,
          services.IMutateAdsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AdService.mutateAds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AgeRangeViewService
   */
  public get ageRangeViews() {
    const service = this.loadService<services.AgeRangeViewService>(
      "AgeRangeViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.AgeRangeView in full detail
       * @warning Don't use get in production!
       * @returns resources.AgeRangeView
       */
      get: async (resourceName: string): Promise<resources.AgeRangeView> => {
        const request = new services.GetAgeRangeViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAgeRangeView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/AssetService
   */
  public get assets() {
    const service = this.loadService<services.AssetService>(
      "AssetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateAssetsRequest, "response_content_type">
    >;
    return {
      /**
       * @description Retrieve a resources.Asset in full detail
       * @warning Don't use get in production!
       * @returns resources.Asset
       */
      get: async (resourceName: string): Promise<resources.Asset> => {
        const request = new services.GetAssetRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getAsset(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IAsset
       * @returns services.MutateAssetsResponse
       */
      create: async (
        assets: (resources.IAsset | resources.Asset)[],
        options?: MutateOptions
      ): Promise<services.MutateAssetsResponse> => {
        const ops = this.buildOperations<
          services.AssetOperation,
          resources.IAsset
        >("create", assets);
        const request = this.buildRequest<
          services.AssetOperation,
          services.IMutateAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetService.mutateAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IAsset
       * @returns services.MutateAssetsResponse
       */
      update: async (
        assets: (resources.IAsset | resources.Asset)[],
        options?: MutateOptions
      ): Promise<services.MutateAssetsResponse> => {
        const ops = this.buildOperations<
          services.AssetOperation,
          resources.IAsset
        >(
          "update",
          assets,
          // @ts-expect-error Static class type here is fine
          resources.Asset
        );
        const request = this.buildRequest<
          services.AssetOperation,
          services.IMutateAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "AssetService.mutateAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/BatchJobService
   */
  public get batchJobs() {
    const service = this.loadService<services.BatchJobService>(
      "BatchJobServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @description create resources of type resources.IBatchJob
       * @returns services.MutateBatchJobResponse
       */
      create: async (
        batchJobs: (resources.IBatchJob | resources.BatchJob)[],
        options?: MutateOptions
      ): Promise<services.MutateBatchJobResponse> => {
        const ops = this.buildOperations<
          services.BatchJobOperation,
          resources.IBatchJob
        >("create", batchJobs);
        const request = this.buildRequest<
          services.BatchJobOperation,
          services.IMutateBatchJobRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BatchJobService.mutateBatchJob",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBatchJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description Retrieve a resources.BatchJob in full detail
       * @warning Don't use get in production!
       * @returns resources.BatchJob
       */
      get: async (resourceName: string): Promise<resources.BatchJob> => {
        const request = new services.GetBatchJobRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getBatchJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/BatchJobService#listbatchjobresults
       */
      listBatchJobResults: async (
        request: services.ListBatchJobResultsRequest
      ): Promise<services.ListBatchJobResultsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listBatchJobResults(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/BatchJobService#runbatchjob
       */
      runBatchJob: async (
        request: services.RunBatchJobRequest
      ): Promise<longrunning.Operation> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.runBatchJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/BatchJobService#addbatchjoboperations
       */
      addBatchJobOperations: async (
        request: services.AddBatchJobOperationsRequest
      ): Promise<services.AddBatchJobOperationsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.addBatchJobOperations(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/BiddingStrategyService
   */
  public get biddingStrategies() {
    const service = this.loadService<services.BiddingStrategyService>(
      "BiddingStrategyServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateBiddingStrategiesRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.BiddingStrategy in full detail
       * @warning Don't use get in production!
       * @returns resources.BiddingStrategy
       */
      get: async (resourceName: string): Promise<resources.BiddingStrategy> => {
        const request = new services.GetBiddingStrategyRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getBiddingStrategy(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IBiddingStrategy
       * @returns services.MutateBiddingStrategiesResponse
       */
      create: async (
        biddingStrategies: (
          | resources.IBiddingStrategy
          | resources.BiddingStrategy
        )[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingStrategiesResponse> => {
        const ops = this.buildOperations<
          services.BiddingStrategyOperation,
          resources.IBiddingStrategy
        >("create", biddingStrategies);
        const request = this.buildRequest<
          services.BiddingStrategyOperation,
          services.IMutateBiddingStrategiesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BiddingStrategyService.mutateBiddingStrategies",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingStrategies(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IBiddingStrategy
       * @returns services.MutateBiddingStrategiesResponse
       */
      update: async (
        biddingStrategies: (
          | resources.IBiddingStrategy
          | resources.BiddingStrategy
        )[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingStrategiesResponse> => {
        const ops = this.buildOperations<
          services.BiddingStrategyOperation,
          resources.IBiddingStrategy
        >(
          "update",
          biddingStrategies,
          // @ts-expect-error Static class type here is fine
          resources.BiddingStrategy
        );
        const request = this.buildRequest<
          services.BiddingStrategyOperation,
          services.IMutateBiddingStrategiesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BiddingStrategyService.mutateBiddingStrategies",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingStrategies(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateBiddingStrategiesResponse
       */
      remove: async (
        biddingStrategies: string[],
        options?: MutateOptions
      ): Promise<services.MutateBiddingStrategiesResponse> => {
        const ops = this.buildOperations<
          services.BiddingStrategyOperation,
          string
        >("remove", biddingStrategies);
        const request = this.buildRequest<
          services.BiddingStrategyOperation,
          services.IMutateBiddingStrategiesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BiddingStrategyService.mutateBiddingStrategies",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBiddingStrategies(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignAssetService
   */
  public get campaignAssets() {
    const service = this.loadService<services.CampaignAssetService>(
      "CampaignAssetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignAssetsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignAsset in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignAsset
       */
      get: async (resourceName: string): Promise<resources.CampaignAsset> => {
        const request = new services.GetCampaignAssetRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignAsset(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaignAsset
       * @returns services.MutateCampaignAssetsResponse
       */
      create: async (
        campaignAssets: (resources.ICampaignAsset | resources.CampaignAsset)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignAssetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignAssetOperation,
          resources.ICampaignAsset
        >("create", campaignAssets);
        const request = this.buildRequest<
          services.CampaignAssetOperation,
          services.IMutateCampaignAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignAssetService.mutateCampaignAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignAssetsResponse
       */
      remove: async (
        campaignAssets: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignAssetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignAssetOperation,
          string
        >("remove", campaignAssets);
        const request = this.buildRequest<
          services.CampaignAssetOperation,
          services.IMutateCampaignAssetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignAssetService.mutateCampaignAssets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignAssets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignBidModifierService
   */
  public get campaignBidModifiers() {
    const service = this.loadService<services.CampaignBidModifierService>(
      "CampaignBidModifierServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignBidModifiersRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignBidModifier in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignBidModifier
       */
      get: async (
        resourceName: string
      ): Promise<resources.CampaignBidModifier> => {
        const request = new services.GetCampaignBidModifierRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignBidModifier(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaignBidModifier
       * @returns services.MutateCampaignBidModifiersResponse
       */
      create: async (
        campaignBidModifiers: (
          | resources.ICampaignBidModifier
          | resources.CampaignBidModifier
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.CampaignBidModifierOperation,
          resources.ICampaignBidModifier
        >("create", campaignBidModifiers);
        const request = this.buildRequest<
          services.CampaignBidModifierOperation,
          services.IMutateCampaignBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBidModifierService.mutateCampaignBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignBidModifier
       * @returns services.MutateCampaignBidModifiersResponse
       */
      update: async (
        campaignBidModifiers: (
          | resources.ICampaignBidModifier
          | resources.CampaignBidModifier
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.CampaignBidModifierOperation,
          resources.ICampaignBidModifier
        >(
          "update",
          campaignBidModifiers,
          // @ts-expect-error Static class type here is fine
          resources.CampaignBidModifier
        );
        const request = this.buildRequest<
          services.CampaignBidModifierOperation,
          services.IMutateCampaignBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBidModifierService.mutateCampaignBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignBidModifiersResponse
       */
      remove: async (
        campaignBidModifiers: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBidModifiersResponse> => {
        const ops = this.buildOperations<
          services.CampaignBidModifierOperation,
          string
        >("remove", campaignBidModifiers);
        const request = this.buildRequest<
          services.CampaignBidModifierOperation,
          services.IMutateCampaignBidModifiersRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBidModifierService.mutateCampaignBidModifiers",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBidModifiers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignBudgetService
   */
  public get campaignBudgets() {
    const service = this.loadService<services.CampaignBudgetService>(
      "CampaignBudgetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignBudgetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignBudget in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignBudget
       */
      get: async (resourceName: string): Promise<resources.CampaignBudget> => {
        const request = new services.GetCampaignBudgetRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignBudget(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaignBudget
       * @returns services.MutateCampaignBudgetsResponse
       */
      create: async (
        campaignBudgets: (
          | resources.ICampaignBudget
          | resources.CampaignBudget
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBudgetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignBudgetOperation,
          resources.ICampaignBudget
        >("create", campaignBudgets);
        const request = this.buildRequest<
          services.CampaignBudgetOperation,
          services.IMutateCampaignBudgetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBudgetService.mutateCampaignBudgets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBudgets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignBudget
       * @returns services.MutateCampaignBudgetsResponse
       */
      update: async (
        campaignBudgets: (
          | resources.ICampaignBudget
          | resources.CampaignBudget
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBudgetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignBudgetOperation,
          resources.ICampaignBudget
        >(
          "update",
          campaignBudgets,
          // @ts-expect-error Static class type here is fine
          resources.CampaignBudget
        );
        const request = this.buildRequest<
          services.CampaignBudgetOperation,
          services.IMutateCampaignBudgetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBudgetService.mutateCampaignBudgets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBudgets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignBudgetsResponse
       */
      remove: async (
        campaignBudgets: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignBudgetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignBudgetOperation,
          string
        >("remove", campaignBudgets);
        const request = this.buildRequest<
          services.CampaignBudgetOperation,
          services.IMutateCampaignBudgetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignBudgetService.mutateCampaignBudgets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignBudgets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignCriterionService
   */
  public get campaignCriteria() {
    const service = this.loadService<services.CampaignCriterionService>(
      "CampaignCriterionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignCriteriaRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignCriterion in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignCriterion
       */
      get: async (
        resourceName: string
      ): Promise<resources.CampaignCriterion> => {
        const request = new services.GetCampaignCriterionRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignCriterion(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaignCriterion
       * @returns services.MutateCampaignCriteriaResponse
       */
      create: async (
        campaignCriteria: (
          | resources.ICampaignCriterion
          | resources.CampaignCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CampaignCriterionOperation,
          resources.ICampaignCriterion
        >("create", campaignCriteria);
        const request = this.buildRequest<
          services.CampaignCriterionOperation,
          services.IMutateCampaignCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignCriterionService.mutateCampaignCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignCriterion
       * @returns services.MutateCampaignCriteriaResponse
       */
      update: async (
        campaignCriteria: (
          | resources.ICampaignCriterion
          | resources.CampaignCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CampaignCriterionOperation,
          resources.ICampaignCriterion
        >(
          "update",
          campaignCriteria,
          // @ts-expect-error Static class type here is fine
          resources.CampaignCriterion
        );
        const request = this.buildRequest<
          services.CampaignCriterionOperation,
          services.IMutateCampaignCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignCriterionService.mutateCampaignCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignCriteriaResponse
       */
      remove: async (
        campaignCriteria: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CampaignCriterionOperation,
          string
        >("remove", campaignCriteria);
        const request = this.buildRequest<
          services.CampaignCriterionOperation,
          services.IMutateCampaignCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignCriterionService.mutateCampaignCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignDraftService
   */
  public get campaignDrafts() {
    const service = this.loadService<services.CampaignDraftService>(
      "CampaignDraftServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignDraftsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignDraft in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignDraft
       */
      get: async (resourceName: string): Promise<resources.CampaignDraft> => {
        const request = new services.GetCampaignDraftRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignDraft(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaignDraft
       * @returns services.MutateCampaignDraftsResponse
       */
      create: async (
        campaignDrafts: (resources.ICampaignDraft | resources.CampaignDraft)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignDraftsResponse> => {
        const ops = this.buildOperations<
          services.CampaignDraftOperation,
          resources.ICampaignDraft
        >("create", campaignDrafts);
        const request = this.buildRequest<
          services.CampaignDraftOperation,
          services.IMutateCampaignDraftsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignDraftService.mutateCampaignDrafts",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignDrafts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignDraft
       * @returns services.MutateCampaignDraftsResponse
       */
      update: async (
        campaignDrafts: (resources.ICampaignDraft | resources.CampaignDraft)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignDraftsResponse> => {
        const ops = this.buildOperations<
          services.CampaignDraftOperation,
          resources.ICampaignDraft
        >(
          "update",
          campaignDrafts,
          // @ts-expect-error Static class type here is fine
          resources.CampaignDraft
        );
        const request = this.buildRequest<
          services.CampaignDraftOperation,
          services.IMutateCampaignDraftsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignDraftService.mutateCampaignDrafts",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignDrafts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignDraftsResponse
       */
      remove: async (
        campaignDrafts: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignDraftsResponse> => {
        const ops = this.buildOperations<
          services.CampaignDraftOperation,
          string
        >("remove", campaignDrafts);
        const request = this.buildRequest<
          services.CampaignDraftOperation,
          services.IMutateCampaignDraftsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignDraftService.mutateCampaignDrafts",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignDrafts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignDraftService#promotecampaigndraft
       */
      promoteCampaignDraft: async (
        request: services.PromoteCampaignDraftRequest
      ): Promise<longrunning.Operation> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.promoteCampaignDraft(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignDraftService#listcampaigndraftasyncerrors
       */
      listCampaignDraftAsyncErrors: async (
        request: services.ListCampaignDraftAsyncErrorsRequest
      ): Promise<services.ListCampaignDraftAsyncErrorsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listCampaignDraftAsyncErrors(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignExperimentService
   */
  public get campaignExperiments() {
    const service = this.loadService<services.CampaignExperimentService>(
      "CampaignExperimentServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignExperimentsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignExperiment in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignExperiment
       */
      get: async (
        resourceName: string
      ): Promise<resources.CampaignExperiment> => {
        const request = new services.GetCampaignExperimentRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignExperiment(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignExperimentService#createcampaignexperiment
       */
      createCampaignExperiment: async (
        request: services.CreateCampaignExperimentRequest
      ): Promise<longrunning.Operation> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.createCampaignExperiment(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description update resources of type resources.ICampaignExperiment
       * @returns services.MutateCampaignExperimentsResponse
       */
      update: async (
        campaignExperiments: (
          | resources.ICampaignExperiment
          | resources.CampaignExperiment
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignExperimentsResponse> => {
        const ops = this.buildOperations<
          services.CampaignExperimentOperation,
          resources.ICampaignExperiment
        >(
          "update",
          campaignExperiments,
          // @ts-expect-error Static class type here is fine
          resources.CampaignExperiment
        );
        const request = this.buildRequest<
          services.CampaignExperimentOperation,
          services.IMutateCampaignExperimentsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignExperimentService.mutateCampaignExperiments",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignExperiments(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignExperimentsResponse
       */
      remove: async (
        campaignExperiments: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignExperimentsResponse> => {
        const ops = this.buildOperations<
          services.CampaignExperimentOperation,
          string
        >("remove", campaignExperiments);
        const request = this.buildRequest<
          services.CampaignExperimentOperation,
          services.IMutateCampaignExperimentsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignExperimentService.mutateCampaignExperiments",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignExperiments(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignExperimentService#graduatecampaignexperiment
       */
      graduateCampaignExperiment: async (
        request: services.GraduateCampaignExperimentRequest
      ): Promise<services.GraduateCampaignExperimentResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.graduateCampaignExperiment(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignExperimentService#promotecampaignexperiment
       */
      promoteCampaignExperiment: async (
        request: services.PromoteCampaignExperimentRequest
      ): Promise<longrunning.Operation> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.promoteCampaignExperiment(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignExperimentService#endcampaignexperiment
       */
      endCampaignExperiment: async (
        request: services.EndCampaignExperimentRequest
      ): Promise<protobuf.Empty> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.endCampaignExperiment(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignExperimentService#listcampaignexperimentasyncerrors
       */
      listCampaignExperimentAsyncErrors: async (
        request: services.ListCampaignExperimentAsyncErrorsRequest
      ): Promise<services.ListCampaignExperimentAsyncErrorsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listCampaignExperimentAsyncErrors(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignExtensionSettingService
   */
  public get campaignExtensionSettings() {
    const service = this.loadService<services.CampaignExtensionSettingService>(
      "CampaignExtensionSettingServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignExtensionSettingsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignExtensionSetting in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignExtensionSetting
       */
      get: async (
        resourceName: string
      ): Promise<resources.CampaignExtensionSetting> => {
        const request = new services.GetCampaignExtensionSettingRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignExtensionSetting(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaignExtensionSetting
       * @returns services.MutateCampaignExtensionSettingsResponse
       */
      create: async (
        campaignExtensionSettings: (
          | resources.ICampaignExtensionSetting
          | resources.CampaignExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CampaignExtensionSettingOperation,
          resources.ICampaignExtensionSetting
        >("create", campaignExtensionSettings);
        const request = this.buildRequest<
          services.CampaignExtensionSettingOperation,
          services.IMutateCampaignExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CampaignExtensionSettingService.mutateCampaignExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignExtensionSetting
       * @returns services.MutateCampaignExtensionSettingsResponse
       */
      update: async (
        campaignExtensionSettings: (
          | resources.ICampaignExtensionSetting
          | resources.CampaignExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CampaignExtensionSettingOperation,
          resources.ICampaignExtensionSetting
        >(
          "update",
          campaignExtensionSettings,
          // @ts-expect-error Static class type here is fine
          resources.CampaignExtensionSetting
        );
        const request = this.buildRequest<
          services.CampaignExtensionSettingOperation,
          services.IMutateCampaignExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CampaignExtensionSettingService.mutateCampaignExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignExtensionSettingsResponse
       */
      remove: async (
        campaignExtensionSettings: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CampaignExtensionSettingOperation,
          string
        >("remove", campaignExtensionSettings);
        const request = this.buildRequest<
          services.CampaignExtensionSettingOperation,
          services.IMutateCampaignExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CampaignExtensionSettingService.mutateCampaignExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignFeedService
   */
  public get campaignFeeds() {
    const service = this.loadService<services.CampaignFeedService>(
      "CampaignFeedServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignFeedsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignFeed in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignFeed
       */
      get: async (resourceName: string): Promise<resources.CampaignFeed> => {
        const request = new services.GetCampaignFeedRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignFeed(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaignFeed
       * @returns services.MutateCampaignFeedsResponse
       */
      create: async (
        campaignFeeds: (resources.ICampaignFeed | resources.CampaignFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignFeedsResponse> => {
        const ops = this.buildOperations<
          services.CampaignFeedOperation,
          resources.ICampaignFeed
        >("create", campaignFeeds);
        const request = this.buildRequest<
          services.CampaignFeedOperation,
          services.IMutateCampaignFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignFeedService.mutateCampaignFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaignFeed
       * @returns services.MutateCampaignFeedsResponse
       */
      update: async (
        campaignFeeds: (resources.ICampaignFeed | resources.CampaignFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignFeedsResponse> => {
        const ops = this.buildOperations<
          services.CampaignFeedOperation,
          resources.ICampaignFeed
        >(
          "update",
          campaignFeeds,
          // @ts-expect-error Static class type here is fine
          resources.CampaignFeed
        );
        const request = this.buildRequest<
          services.CampaignFeedOperation,
          services.IMutateCampaignFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignFeedService.mutateCampaignFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignFeedsResponse
       */
      remove: async (
        campaignFeeds: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignFeedsResponse> => {
        const ops = this.buildOperations<
          services.CampaignFeedOperation,
          string
        >("remove", campaignFeeds);
        const request = this.buildRequest<
          services.CampaignFeedOperation,
          services.IMutateCampaignFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignFeedService.mutateCampaignFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignLabelService
   */
  public get campaignLabels() {
    const service = this.loadService<services.CampaignLabelService>(
      "CampaignLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignLabel in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignLabel
       */
      get: async (resourceName: string): Promise<resources.CampaignLabel> => {
        const request = new services.GetCampaignLabelRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignLabel(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaignLabel
       * @returns services.MutateCampaignLabelsResponse
       */
      create: async (
        campaignLabels: (resources.ICampaignLabel | resources.CampaignLabel)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignLabelsResponse> => {
        const ops = this.buildOperations<
          services.CampaignLabelOperation,
          resources.ICampaignLabel
        >("create", campaignLabels);
        const request = this.buildRequest<
          services.CampaignLabelOperation,
          services.IMutateCampaignLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignLabelService.mutateCampaignLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignLabelsResponse
       */
      remove: async (
        campaignLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignLabelsResponse> => {
        const ops = this.buildOperations<
          services.CampaignLabelOperation,
          string
        >("remove", campaignLabels);
        const request = this.buildRequest<
          services.CampaignLabelOperation,
          services.IMutateCampaignLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignLabelService.mutateCampaignLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignService
   */
  public get campaigns() {
    const service = this.loadService<services.CampaignService>(
      "CampaignServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.Campaign in full detail
       * @warning Don't use get in production!
       * @returns resources.Campaign
       */
      get: async (resourceName: string): Promise<resources.Campaign> => {
        const request = new services.GetCampaignRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaign(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaign
       * @returns services.MutateCampaignsResponse
       */
      create: async (
        campaigns: (resources.ICampaign | resources.Campaign)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignsResponse> => {
        const ops = this.buildOperations<
          services.CampaignOperation,
          resources.ICampaign
        >("create", campaigns);
        const request = this.buildRequest<
          services.CampaignOperation,
          services.IMutateCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignService.mutateCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICampaign
       * @returns services.MutateCampaignsResponse
       */
      update: async (
        campaigns: (resources.ICampaign | resources.Campaign)[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignsResponse> => {
        const ops = this.buildOperations<
          services.CampaignOperation,
          resources.ICampaign
        >(
          "update",
          campaigns,
          // @ts-expect-error Static class type here is fine
          resources.Campaign
        );
        const request = this.buildRequest<
          services.CampaignOperation,
          services.IMutateCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignService.mutateCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignsResponse
       */
      remove: async (
        campaigns: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignsResponse> => {
        const ops = this.buildOperations<services.CampaignOperation, string>(
          "remove",
          campaigns
        );
        const request = this.buildRequest<
          services.CampaignOperation,
          services.IMutateCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignService.mutateCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignSharedSetService
   */
  public get campaignSharedSets() {
    const service = this.loadService<services.CampaignSharedSetService>(
      "CampaignSharedSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCampaignSharedSetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CampaignSharedSet in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignSharedSet
       */
      get: async (
        resourceName: string
      ): Promise<resources.CampaignSharedSet> => {
        const request = new services.GetCampaignSharedSetRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignSharedSet(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICampaignSharedSet
       * @returns services.MutateCampaignSharedSetsResponse
       */
      create: async (
        campaignSharedSets: (
          | resources.ICampaignSharedSet
          | resources.CampaignSharedSet
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignSharedSetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignSharedSetOperation,
          resources.ICampaignSharedSet
        >("create", campaignSharedSets);
        const request = this.buildRequest<
          services.CampaignSharedSetOperation,
          services.IMutateCampaignSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignSharedSetService.mutateCampaignSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCampaignSharedSetsResponse
       */
      remove: async (
        campaignSharedSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateCampaignSharedSetsResponse> => {
        const ops = this.buildOperations<
          services.CampaignSharedSetOperation,
          string
        >("remove", campaignSharedSets);
        const request = this.buildRequest<
          services.CampaignSharedSetOperation,
          services.IMutateCampaignSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CampaignSharedSetService.mutateCampaignSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCampaignSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ConversionActionService
   */
  public get conversionActions() {
    const service = this.loadService<services.ConversionActionService>(
      "ConversionActionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateConversionActionsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.ConversionAction in full detail
       * @warning Don't use get in production!
       * @returns resources.ConversionAction
       */
      get: async (
        resourceName: string
      ): Promise<resources.ConversionAction> => {
        const request = new services.GetConversionActionRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getConversionAction(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IConversionAction
       * @returns services.MutateConversionActionsResponse
       */
      create: async (
        conversionActions: (
          | resources.IConversionAction
          | resources.ConversionAction
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionActionsResponse> => {
        const ops = this.buildOperations<
          services.ConversionActionOperation,
          resources.IConversionAction
        >("create", conversionActions);
        const request = this.buildRequest<
          services.ConversionActionOperation,
          services.IMutateConversionActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionActionService.mutateConversionActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IConversionAction
       * @returns services.MutateConversionActionsResponse
       */
      update: async (
        conversionActions: (
          | resources.IConversionAction
          | resources.ConversionAction
        )[],
        options?: MutateOptions
      ): Promise<services.MutateConversionActionsResponse> => {
        const ops = this.buildOperations<
          services.ConversionActionOperation,
          resources.IConversionAction
        >(
          "update",
          conversionActions,
          // @ts-expect-error Static class type here is fine
          resources.ConversionAction
        );
        const request = this.buildRequest<
          services.ConversionActionOperation,
          services.IMutateConversionActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionActionService.mutateConversionActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateConversionActionsResponse
       */
      remove: async (
        conversionActions: string[],
        options?: MutateOptions
      ): Promise<services.MutateConversionActionsResponse> => {
        const ops = this.buildOperations<
          services.ConversionActionOperation,
          string
        >("remove", conversionActions);
        const request = this.buildRequest<
          services.ConversionActionOperation,
          services.IMutateConversionActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ConversionActionService.mutateConversionActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateConversionActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerExtensionSettingService
   */
  public get customerExtensionSettings() {
    const service = this.loadService<services.CustomerExtensionSettingService>(
      "CustomerExtensionSettingServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerExtensionSettingsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CustomerExtensionSetting in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomerExtensionSetting
       */
      get: async (
        resourceName: string
      ): Promise<resources.CustomerExtensionSetting> => {
        const request = new services.GetCustomerExtensionSettingRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomerExtensionSetting(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICustomerExtensionSetting
       * @returns services.MutateCustomerExtensionSettingsResponse
       */
      create: async (
        customerExtensionSettings: (
          | resources.ICustomerExtensionSetting
          | resources.CustomerExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CustomerExtensionSettingOperation,
          resources.ICustomerExtensionSetting
        >("create", customerExtensionSettings);
        const request = this.buildRequest<
          services.CustomerExtensionSettingOperation,
          services.IMutateCustomerExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerExtensionSettingService.mutateCustomerExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomerExtensionSetting
       * @returns services.MutateCustomerExtensionSettingsResponse
       */
      update: async (
        customerExtensionSettings: (
          | resources.ICustomerExtensionSetting
          | resources.CustomerExtensionSetting
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CustomerExtensionSettingOperation,
          resources.ICustomerExtensionSetting
        >(
          "update",
          customerExtensionSettings,
          // @ts-expect-error Static class type here is fine
          resources.CustomerExtensionSetting
        );
        const request = this.buildRequest<
          services.CustomerExtensionSettingOperation,
          services.IMutateCustomerExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerExtensionSettingService.mutateCustomerExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerExtensionSettingsResponse
       */
      remove: async (
        customerExtensionSettings: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerExtensionSettingsResponse> => {
        const ops = this.buildOperations<
          services.CustomerExtensionSettingOperation,
          string
        >("remove", customerExtensionSettings);
        const request = this.buildRequest<
          services.CustomerExtensionSettingOperation,
          services.IMutateCustomerExtensionSettingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerExtensionSettingService.mutateCustomerExtensionSettings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerExtensionSettings(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerFeedService
   */
  public get customerFeeds() {
    const service = this.loadService<services.CustomerFeedService>(
      "CustomerFeedServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerFeedsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CustomerFeed in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomerFeed
       */
      get: async (resourceName: string): Promise<resources.CustomerFeed> => {
        const request = new services.GetCustomerFeedRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomerFeed(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICustomerFeed
       * @returns services.MutateCustomerFeedsResponse
       */
      create: async (
        customerFeeds: (resources.ICustomerFeed | resources.CustomerFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerFeedsResponse> => {
        const ops = this.buildOperations<
          services.CustomerFeedOperation,
          resources.ICustomerFeed
        >("create", customerFeeds);
        const request = this.buildRequest<
          services.CustomerFeedOperation,
          services.IMutateCustomerFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerFeedService.mutateCustomerFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomerFeed
       * @returns services.MutateCustomerFeedsResponse
       */
      update: async (
        customerFeeds: (resources.ICustomerFeed | resources.CustomerFeed)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerFeedsResponse> => {
        const ops = this.buildOperations<
          services.CustomerFeedOperation,
          resources.ICustomerFeed
        >(
          "update",
          customerFeeds,
          // @ts-expect-error Static class type here is fine
          resources.CustomerFeed
        );
        const request = this.buildRequest<
          services.CustomerFeedOperation,
          services.IMutateCustomerFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerFeedService.mutateCustomerFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerFeedsResponse
       */
      remove: async (
        customerFeeds: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerFeedsResponse> => {
        const ops = this.buildOperations<
          services.CustomerFeedOperation,
          string
        >("remove", customerFeeds);
        const request = this.buildRequest<
          services.CustomerFeedOperation,
          services.IMutateCustomerFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerFeedService.mutateCustomerFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerLabelService
   */
  public get customerLabels() {
    const service = this.loadService<services.CustomerLabelService>(
      "CustomerLabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerLabelsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CustomerLabel in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomerLabel
       */
      get: async (resourceName: string): Promise<resources.CustomerLabel> => {
        const request = new services.GetCustomerLabelRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomerLabel(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICustomerLabel
       * @returns services.MutateCustomerLabelsResponse
       */
      create: async (
        customerLabels: (resources.ICustomerLabel | resources.CustomerLabel)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerLabelsResponse> => {
        const ops = this.buildOperations<
          services.CustomerLabelOperation,
          resources.ICustomerLabel
        >("create", customerLabels);
        const request = this.buildRequest<
          services.CustomerLabelOperation,
          services.IMutateCustomerLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerLabelService.mutateCustomerLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerLabelsResponse
       */
      remove: async (
        customerLabels: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerLabelsResponse> => {
        const ops = this.buildOperations<
          services.CustomerLabelOperation,
          string
        >("remove", customerLabels);
        const request = this.buildRequest<
          services.CustomerLabelOperation,
          services.IMutateCustomerLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerLabelService.mutateCustomerLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerNegativeCriterionService
   */
  public get customerNegativeCriteria() {
    const service = this.loadService<services.CustomerNegativeCriterionService>(
      "CustomerNegativeCriterionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerNegativeCriteriaRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.CustomerNegativeCriterion in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomerNegativeCriterion
       */
      get: async (
        resourceName: string
      ): Promise<resources.CustomerNegativeCriterion> => {
        const request = new services.GetCustomerNegativeCriterionRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomerNegativeCriterion(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICustomerNegativeCriterion
       * @returns services.MutateCustomerNegativeCriteriaResponse
       */
      create: async (
        customerNegativeCriteria: (
          | resources.ICustomerNegativeCriterion
          | resources.CustomerNegativeCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerNegativeCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CustomerNegativeCriterionOperation,
          resources.ICustomerNegativeCriterion
        >("create", customerNegativeCriteria);
        const request = this.buildRequest<
          services.CustomerNegativeCriterionOperation,
          services.IMutateCustomerNegativeCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerNegativeCriterionService.mutateCustomerNegativeCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerNegativeCriteria(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerNegativeCriteriaResponse
       */
      remove: async (
        customerNegativeCriteria: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerNegativeCriteriaResponse> => {
        const ops = this.buildOperations<
          services.CustomerNegativeCriterionOperation,
          string
        >("remove", customerNegativeCriteria);
        const request = this.buildRequest<
          services.CustomerNegativeCriterionOperation,
          services.IMutateCustomerNegativeCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerNegativeCriterionService.mutateCustomerNegativeCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerNegativeCriteria(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerService
   */
  public get customers() {
    const service = this.loadService<services.CustomerService>(
      "CustomerServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateCustomerRequest,
        "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.Customer in full detail
       * @warning Don't use get in production!
       * @returns resources.Customer
       */
      get: async (resourceName: string): Promise<resources.Customer> => {
        const request = new services.GetCustomerRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomer(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description update resources of type resources.ICustomer
       * @returns services.MutateCustomerResponse
       */
      update: async (
        customers: (resources.ICustomer | resources.Customer)[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerResponse> => {
        const ops = this.buildOperations<
          services.CustomerOperation,
          resources.ICustomer
        >(
          "update",
          customers,
          // @ts-expect-error Static class type here is fine
          resources.Customer
        );
        const request = this.buildRequest<
          services.CustomerOperation,
          services.IMutateCustomerRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerService.mutateCustomer",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomer(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerService#listaccessiblecustomers
       */
      listAccessibleCustomers: async (
        request: services.ListAccessibleCustomersRequest
      ): Promise<services.ListAccessibleCustomersResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listAccessibleCustomers(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerService#createcustomerclient
       */
      createCustomerClient: async (
        request: services.CreateCustomerClientRequest
      ): Promise<services.CreateCustomerClientResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.createCustomerClient(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ExtensionFeedItemService
   */
  public get extensionFeedItems() {
    const service = this.loadService<services.ExtensionFeedItemService>(
      "ExtensionFeedItemServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateExtensionFeedItemsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.ExtensionFeedItem in full detail
       * @warning Don't use get in production!
       * @returns resources.ExtensionFeedItem
       */
      get: async (
        resourceName: string
      ): Promise<resources.ExtensionFeedItem> => {
        const request = new services.GetExtensionFeedItemRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getExtensionFeedItem(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IExtensionFeedItem
       * @returns services.MutateExtensionFeedItemsResponse
       */
      create: async (
        extensionFeedItems: (
          | resources.IExtensionFeedItem
          | resources.ExtensionFeedItem
        )[],
        options?: MutateOptions
      ): Promise<services.MutateExtensionFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.ExtensionFeedItemOperation,
          resources.IExtensionFeedItem
        >("create", extensionFeedItems);
        const request = this.buildRequest<
          services.ExtensionFeedItemOperation,
          services.IMutateExtensionFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExtensionFeedItemService.mutateExtensionFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExtensionFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IExtensionFeedItem
       * @returns services.MutateExtensionFeedItemsResponse
       */
      update: async (
        extensionFeedItems: (
          | resources.IExtensionFeedItem
          | resources.ExtensionFeedItem
        )[],
        options?: MutateOptions
      ): Promise<services.MutateExtensionFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.ExtensionFeedItemOperation,
          resources.IExtensionFeedItem
        >(
          "update",
          extensionFeedItems,
          // @ts-expect-error Static class type here is fine
          resources.ExtensionFeedItem
        );
        const request = this.buildRequest<
          services.ExtensionFeedItemOperation,
          services.IMutateExtensionFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExtensionFeedItemService.mutateExtensionFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExtensionFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateExtensionFeedItemsResponse
       */
      remove: async (
        extensionFeedItems: string[],
        options?: MutateOptions
      ): Promise<services.MutateExtensionFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.ExtensionFeedItemOperation,
          string
        >("remove", extensionFeedItems);
        const request = this.buildRequest<
          services.ExtensionFeedItemOperation,
          services.IMutateExtensionFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "ExtensionFeedItemService.mutateExtensionFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateExtensionFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/FeedItemService
   */
  public get feedItems() {
    const service = this.loadService<services.FeedItemService>(
      "FeedItemServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedItemsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.FeedItem in full detail
       * @warning Don't use get in production!
       * @returns resources.FeedItem
       */
      get: async (resourceName: string): Promise<resources.FeedItem> => {
        const request = new services.GetFeedItemRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getFeedItem(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IFeedItem
       * @returns services.MutateFeedItemsResponse
       */
      create: async (
        feedItems: (resources.IFeedItem | resources.FeedItem)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemOperation,
          resources.IFeedItem
        >("create", feedItems);
        const request = this.buildRequest<
          services.FeedItemOperation,
          services.IMutateFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemService.mutateFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IFeedItem
       * @returns services.MutateFeedItemsResponse
       */
      update: async (
        feedItems: (resources.IFeedItem | resources.FeedItem)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemOperation,
          resources.IFeedItem
        >(
          "update",
          feedItems,
          // @ts-expect-error Static class type here is fine
          resources.FeedItem
        );
        const request = this.buildRequest<
          services.FeedItemOperation,
          services.IMutateFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemService.mutateFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedItemsResponse
       */
      remove: async (
        feedItems: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemsResponse> => {
        const ops = this.buildOperations<services.FeedItemOperation, string>(
          "remove",
          feedItems
        );
        const request = this.buildRequest<
          services.FeedItemOperation,
          services.IMutateFeedItemsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemService.mutateFeedItems",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItems(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/FeedItemSetLinkService
   */
  public get feedItemSetLinks() {
    const service = this.loadService<services.FeedItemSetLinkService>(
      "FeedItemSetLinkServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedItemSetLinksRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.FeedItemSetLink in full detail
       * @warning Don't use get in production!
       * @returns resources.FeedItemSetLink
       */
      get: async (resourceName: string): Promise<resources.FeedItemSetLink> => {
        const request = new services.GetFeedItemSetLinkRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getFeedItemSetLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IFeedItemSetLink
       * @returns services.MutateFeedItemSetLinksResponse
       */
      create: async (
        feedItemSetLinks: (
          | resources.IFeedItemSetLink
          | resources.FeedItemSetLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetLinksResponse> => {
        const ops = this.buildOperations<
          services.FeedItemSetLinkOperation,
          resources.IFeedItemSetLink
        >("create", feedItemSetLinks);
        const request = this.buildRequest<
          services.FeedItemSetLinkOperation,
          services.IMutateFeedItemSetLinksRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetLinkService.mutateFeedItemSetLinks",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSetLinks(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedItemSetLinksResponse
       */
      remove: async (
        feedItemSetLinks: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetLinksResponse> => {
        const ops = this.buildOperations<
          services.FeedItemSetLinkOperation,
          string
        >("remove", feedItemSetLinks);
        const request = this.buildRequest<
          services.FeedItemSetLinkOperation,
          services.IMutateFeedItemSetLinksRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetLinkService.mutateFeedItemSetLinks",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSetLinks(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/FeedItemSetService
   */
  public get feedItemSets() {
    const service = this.loadService<services.FeedItemSetService>(
      "FeedItemSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedItemSetsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.FeedItemSet in full detail
       * @warning Don't use get in production!
       * @returns resources.FeedItemSet
       */
      get: async (resourceName: string): Promise<resources.FeedItemSet> => {
        const request = new services.GetFeedItemSetRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getFeedItemSet(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IFeedItemSet
       * @returns services.MutateFeedItemSetsResponse
       */
      create: async (
        feedItemSets: (resources.IFeedItemSet | resources.FeedItemSet)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemSetOperation,
          resources.IFeedItemSet
        >("create", feedItemSets);
        const request = this.buildRequest<
          services.FeedItemSetOperation,
          services.IMutateFeedItemSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetService.mutateFeedItemSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IFeedItemSet
       * @returns services.MutateFeedItemSetsResponse
       */
      update: async (
        feedItemSets: (resources.IFeedItemSet | resources.FeedItemSet)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemSetOperation,
          resources.IFeedItemSet
        >(
          "update",
          feedItemSets,
          // @ts-expect-error Static class type here is fine
          resources.FeedItemSet
        );
        const request = this.buildRequest<
          services.FeedItemSetOperation,
          services.IMutateFeedItemSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetService.mutateFeedItemSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedItemSetsResponse
       */
      remove: async (
        feedItemSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemSetsResponse> => {
        const ops = this.buildOperations<services.FeedItemSetOperation, string>(
          "remove",
          feedItemSets
        );
        const request = this.buildRequest<
          services.FeedItemSetOperation,
          services.IMutateFeedItemSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemSetService.mutateFeedItemSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/FeedItemTargetService
   */
  public get feedItemTargets() {
    const service = this.loadService<services.FeedItemTargetService>(
      "FeedItemTargetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateFeedItemTargetsRequest, "response_content_type">
    >;
    return {
      /**
       * @description Retrieve a resources.FeedItemTarget in full detail
       * @warning Don't use get in production!
       * @returns resources.FeedItemTarget
       */
      get: async (resourceName: string): Promise<resources.FeedItemTarget> => {
        const request = new services.GetFeedItemTargetRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getFeedItemTarget(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IFeedItemTarget
       * @returns services.MutateFeedItemTargetsResponse
       */
      create: async (
        feedItemTargets: (
          | resources.IFeedItemTarget
          | resources.FeedItemTarget
        )[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemTargetsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemTargetOperation,
          resources.IFeedItemTarget
        >("create", feedItemTargets);
        const request = this.buildRequest<
          services.FeedItemTargetOperation,
          services.IMutateFeedItemTargetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemTargetService.mutateFeedItemTargets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemTargets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedItemTargetsResponse
       */
      remove: async (
        feedItemTargets: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedItemTargetsResponse> => {
        const ops = this.buildOperations<
          services.FeedItemTargetOperation,
          string
        >("remove", feedItemTargets);
        const request = this.buildRequest<
          services.FeedItemTargetOperation,
          services.IMutateFeedItemTargetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedItemTargetService.mutateFeedItemTargets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedItemTargets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/FeedMappingService
   */
  public get feedMappings() {
    const service = this.loadService<services.FeedMappingService>(
      "FeedMappingServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedMappingsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.FeedMapping in full detail
       * @warning Don't use get in production!
       * @returns resources.FeedMapping
       */
      get: async (resourceName: string): Promise<resources.FeedMapping> => {
        const request = new services.GetFeedMappingRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getFeedMapping(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IFeedMapping
       * @returns services.MutateFeedMappingsResponse
       */
      create: async (
        feedMappings: (resources.IFeedMapping | resources.FeedMapping)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedMappingsResponse> => {
        const ops = this.buildOperations<
          services.FeedMappingOperation,
          resources.IFeedMapping
        >("create", feedMappings);
        const request = this.buildRequest<
          services.FeedMappingOperation,
          services.IMutateFeedMappingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedMappingService.mutateFeedMappings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedMappings(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedMappingsResponse
       */
      remove: async (
        feedMappings: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedMappingsResponse> => {
        const ops = this.buildOperations<services.FeedMappingOperation, string>(
          "remove",
          feedMappings
        );
        const request = this.buildRequest<
          services.FeedMappingOperation,
          services.IMutateFeedMappingsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedMappingService.mutateFeedMappings",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeedMappings(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/FeedService
   */
  public get feeds() {
    const service = this.loadService<services.FeedService>("FeedServiceClient");
    type MutateOptions = Partial<
      Pick<
        services.IMutateFeedsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.Feed in full detail
       * @warning Don't use get in production!
       * @returns resources.Feed
       */
      get: async (resourceName: string): Promise<resources.Feed> => {
        const request = new services.GetFeedRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getFeed(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IFeed
       * @returns services.MutateFeedsResponse
       */
      create: async (
        feeds: (resources.IFeed | resources.Feed)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedsResponse> => {
        const ops = this.buildOperations<
          services.FeedOperation,
          resources.IFeed
        >("create", feeds);
        const request = this.buildRequest<
          services.FeedOperation,
          services.IMutateFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedService.mutateFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IFeed
       * @returns services.MutateFeedsResponse
       */
      update: async (
        feeds: (resources.IFeed | resources.Feed)[],
        options?: MutateOptions
      ): Promise<services.MutateFeedsResponse> => {
        const ops = this.buildOperations<
          services.FeedOperation,
          resources.IFeed
        >(
          "update",
          feeds,
          // @ts-expect-error Static class type here is fine
          resources.Feed
        );
        const request = this.buildRequest<
          services.FeedOperation,
          services.IMutateFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedService.mutateFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateFeedsResponse
       */
      remove: async (
        feeds: string[],
        options?: MutateOptions
      ): Promise<services.MutateFeedsResponse> => {
        const ops = this.buildOperations<services.FeedOperation, string>(
          "remove",
          feeds
        );
        const request = this.buildRequest<
          services.FeedOperation,
          services.IMutateFeedsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "FeedService.mutateFeeds",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateFeeds(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanAdGroupKeywordService
   */
  public get keywordPlanAdGroupKeywords() {
    const service = this.loadService<services.KeywordPlanAdGroupKeywordService>(
      "KeywordPlanAdGroupKeywordServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlanAdGroupKeywordsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.KeywordPlanAdGroupKeyword in full detail
       * @warning Don't use get in production!
       * @returns resources.KeywordPlanAdGroupKeyword
       */
      get: async (
        resourceName: string
      ): Promise<resources.KeywordPlanAdGroupKeyword> => {
        const request = new services.GetKeywordPlanAdGroupKeywordRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getKeywordPlanAdGroupKeyword(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IKeywordPlanAdGroupKeyword
       * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
       */
      create: async (
        keywordPlanAdGroupKeywords: (
          | resources.IKeywordPlanAdGroupKeyword
          | resources.KeywordPlanAdGroupKeyword
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupKeywordOperation,
          resources.IKeywordPlanAdGroupKeyword
        >("create", keywordPlanAdGroupKeywords);
        const request = this.buildRequest<
          services.KeywordPlanAdGroupKeywordOperation,
          services.IMutateKeywordPlanAdGroupKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroupKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlanAdGroupKeyword
       * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
       */
      update: async (
        keywordPlanAdGroupKeywords: (
          | resources.IKeywordPlanAdGroupKeyword
          | resources.KeywordPlanAdGroupKeyword
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupKeywordOperation,
          resources.IKeywordPlanAdGroupKeyword
        >(
          "update",
          keywordPlanAdGroupKeywords,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlanAdGroupKeyword
        );
        const request = this.buildRequest<
          services.KeywordPlanAdGroupKeywordOperation,
          services.IMutateKeywordPlanAdGroupKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroupKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
       */
      remove: async (
        keywordPlanAdGroupKeywords: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupKeywordOperation,
          string
        >("remove", keywordPlanAdGroupKeywords);
        const request = this.buildRequest<
          services.KeywordPlanAdGroupKeywordOperation,
          services.IMutateKeywordPlanAdGroupKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroupKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanAdGroupService
   */
  public get keywordPlanAdGroups() {
    const service = this.loadService<services.KeywordPlanAdGroupService>(
      "KeywordPlanAdGroupServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlanAdGroupsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.KeywordPlanAdGroup in full detail
       * @warning Don't use get in production!
       * @returns resources.KeywordPlanAdGroup
       */
      get: async (
        resourceName: string
      ): Promise<resources.KeywordPlanAdGroup> => {
        const request = new services.GetKeywordPlanAdGroupRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getKeywordPlanAdGroup(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IKeywordPlanAdGroup
       * @returns services.MutateKeywordPlanAdGroupsResponse
       */
      create: async (
        keywordPlanAdGroups: (
          | resources.IKeywordPlanAdGroup
          | resources.KeywordPlanAdGroup
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupOperation,
          resources.IKeywordPlanAdGroup
        >("create", keywordPlanAdGroups);
        const request = this.buildRequest<
          services.KeywordPlanAdGroupOperation,
          services.IMutateKeywordPlanAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlanAdGroup
       * @returns services.MutateKeywordPlanAdGroupsResponse
       */
      update: async (
        keywordPlanAdGroups: (
          | resources.IKeywordPlanAdGroup
          | resources.KeywordPlanAdGroup
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupOperation,
          resources.IKeywordPlanAdGroup
        >(
          "update",
          keywordPlanAdGroups,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlanAdGroup
        );
        const request = this.buildRequest<
          services.KeywordPlanAdGroupOperation,
          services.IMutateKeywordPlanAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlanAdGroupsResponse
       */
      remove: async (
        keywordPlanAdGroups: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanAdGroupsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanAdGroupOperation,
          string
        >("remove", keywordPlanAdGroups);
        const request = this.buildRequest<
          services.KeywordPlanAdGroupOperation,
          services.IMutateKeywordPlanAdGroupsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanAdGroups(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanCampaignKeywordService
   */
  public get keywordPlanCampaignKeywords() {
    const service = this.loadService<services.KeywordPlanCampaignKeywordService>(
      "KeywordPlanCampaignKeywordServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlanCampaignKeywordsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.KeywordPlanCampaignKeyword in full detail
       * @warning Don't use get in production!
       * @returns resources.KeywordPlanCampaignKeyword
       */
      get: async (
        resourceName: string
      ): Promise<resources.KeywordPlanCampaignKeyword> => {
        const request = new services.GetKeywordPlanCampaignKeywordRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getKeywordPlanCampaignKeyword(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IKeywordPlanCampaignKeyword
       * @returns services.MutateKeywordPlanCampaignKeywordsResponse
       */
      create: async (
        keywordPlanCampaignKeywords: (
          | resources.IKeywordPlanCampaignKeyword
          | resources.KeywordPlanCampaignKeyword
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignKeywordOperation,
          resources.IKeywordPlanCampaignKeyword
        >("create", keywordPlanCampaignKeywords);
        const request = this.buildRequest<
          services.KeywordPlanCampaignKeywordOperation,
          services.IMutateKeywordPlanCampaignKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaignKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlanCampaignKeyword
       * @returns services.MutateKeywordPlanCampaignKeywordsResponse
       */
      update: async (
        keywordPlanCampaignKeywords: (
          | resources.IKeywordPlanCampaignKeyword
          | resources.KeywordPlanCampaignKeyword
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignKeywordOperation,
          resources.IKeywordPlanCampaignKeyword
        >(
          "update",
          keywordPlanCampaignKeywords,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlanCampaignKeyword
        );
        const request = this.buildRequest<
          services.KeywordPlanCampaignKeywordOperation,
          services.IMutateKeywordPlanCampaignKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaignKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlanCampaignKeywordsResponse
       */
      remove: async (
        keywordPlanCampaignKeywords: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignKeywordsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignKeywordOperation,
          string
        >("remove", keywordPlanCampaignKeywords);
        const request = this.buildRequest<
          services.KeywordPlanCampaignKeywordOperation,
          services.IMutateKeywordPlanCampaignKeywordsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaignKeywords(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanCampaignService
   */
  public get keywordPlanCampaigns() {
    const service = this.loadService<services.KeywordPlanCampaignService>(
      "KeywordPlanCampaignServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlanCampaignsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.KeywordPlanCampaign in full detail
       * @warning Don't use get in production!
       * @returns resources.KeywordPlanCampaign
       */
      get: async (
        resourceName: string
      ): Promise<resources.KeywordPlanCampaign> => {
        const request = new services.GetKeywordPlanCampaignRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getKeywordPlanCampaign(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IKeywordPlanCampaign
       * @returns services.MutateKeywordPlanCampaignsResponse
       */
      create: async (
        keywordPlanCampaigns: (
          | resources.IKeywordPlanCampaign
          | resources.KeywordPlanCampaign
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignOperation,
          resources.IKeywordPlanCampaign
        >("create", keywordPlanCampaigns);
        const request = this.buildRequest<
          services.KeywordPlanCampaignOperation,
          services.IMutateKeywordPlanCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlanCampaign
       * @returns services.MutateKeywordPlanCampaignsResponse
       */
      update: async (
        keywordPlanCampaigns: (
          | resources.IKeywordPlanCampaign
          | resources.KeywordPlanCampaign
        )[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignOperation,
          resources.IKeywordPlanCampaign
        >(
          "update",
          keywordPlanCampaigns,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlanCampaign
        );
        const request = this.buildRequest<
          services.KeywordPlanCampaignOperation,
          services.IMutateKeywordPlanCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlanCampaignsResponse
       */
      remove: async (
        keywordPlanCampaigns: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlanCampaignsResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanCampaignOperation,
          string
        >("remove", keywordPlanCampaigns);
        const request = this.buildRequest<
          services.KeywordPlanCampaignOperation,
          services.IMutateKeywordPlanCampaignsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlanCampaigns(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanService
   */
  public get keywordPlans() {
    const service = this.loadService<services.KeywordPlanService>(
      "KeywordPlanServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateKeywordPlansRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.KeywordPlan in full detail
       * @warning Don't use get in production!
       * @returns resources.KeywordPlan
       */
      get: async (resourceName: string): Promise<resources.KeywordPlan> => {
        const request = new services.GetKeywordPlanRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getKeywordPlan(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IKeywordPlan
       * @returns services.MutateKeywordPlansResponse
       */
      create: async (
        keywordPlans: (resources.IKeywordPlan | resources.KeywordPlan)[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlansResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanOperation,
          resources.IKeywordPlan
        >("create", keywordPlans);
        const request = this.buildRequest<
          services.KeywordPlanOperation,
          services.IMutateKeywordPlansRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanService.mutateKeywordPlans",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlans(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IKeywordPlan
       * @returns services.MutateKeywordPlansResponse
       */
      update: async (
        keywordPlans: (resources.IKeywordPlan | resources.KeywordPlan)[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlansResponse> => {
        const ops = this.buildOperations<
          services.KeywordPlanOperation,
          resources.IKeywordPlan
        >(
          "update",
          keywordPlans,
          // @ts-expect-error Static class type here is fine
          resources.KeywordPlan
        );
        const request = this.buildRequest<
          services.KeywordPlanOperation,
          services.IMutateKeywordPlansRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanService.mutateKeywordPlans",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlans(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateKeywordPlansResponse
       */
      remove: async (
        keywordPlans: string[],
        options?: MutateOptions
      ): Promise<services.MutateKeywordPlansResponse> => {
        const ops = this.buildOperations<services.KeywordPlanOperation, string>(
          "remove",
          keywordPlans
        );
        const request = this.buildRequest<
          services.KeywordPlanOperation,
          services.IMutateKeywordPlansRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "KeywordPlanService.mutateKeywordPlans",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateKeywordPlans(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanService#generateforecastcurve
       */
      generateForecastCurve: async (
        request: services.GenerateForecastCurveRequest
      ): Promise<services.GenerateForecastCurveResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateForecastCurve(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanService#generateforecasttimeseries
       */
      generateForecastTimeSeries: async (
        request: services.GenerateForecastTimeSeriesRequest
      ): Promise<services.GenerateForecastTimeSeriesResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateForecastTimeSeries(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanService#generateforecastmetrics
       */
      generateForecastMetrics: async (
        request: services.GenerateForecastMetricsRequest
      ): Promise<services.GenerateForecastMetricsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateForecastMetrics(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanService#generatehistoricalmetrics
       */
      generateHistoricalMetrics: async (
        request: services.GenerateHistoricalMetricsRequest
      ): Promise<services.GenerateHistoricalMetricsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateHistoricalMetrics(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/LabelService
   */
  public get labels() {
    const service = this.loadService<services.LabelService>(
      "LabelServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateLabelsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.Label in full detail
       * @warning Don't use get in production!
       * @returns resources.Label
       */
      get: async (resourceName: string): Promise<resources.Label> => {
        const request = new services.GetLabelRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getLabel(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ILabel
       * @returns services.MutateLabelsResponse
       */
      create: async (
        labels: (resources.ILabel | resources.Label)[],
        options?: MutateOptions
      ): Promise<services.MutateLabelsResponse> => {
        const ops = this.buildOperations<
          services.LabelOperation,
          resources.ILabel
        >("create", labels);
        const request = this.buildRequest<
          services.LabelOperation,
          services.IMutateLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "LabelService.mutateLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ILabel
       * @returns services.MutateLabelsResponse
       */
      update: async (
        labels: (resources.ILabel | resources.Label)[],
        options?: MutateOptions
      ): Promise<services.MutateLabelsResponse> => {
        const ops = this.buildOperations<
          services.LabelOperation,
          resources.ILabel
        >(
          "update",
          labels,
          // @ts-expect-error Static class type here is fine
          resources.Label
        );
        const request = this.buildRequest<
          services.LabelOperation,
          services.IMutateLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "LabelService.mutateLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateLabelsResponse
       */
      remove: async (
        labels: string[],
        options?: MutateOptions
      ): Promise<services.MutateLabelsResponse> => {
        const ops = this.buildOperations<services.LabelOperation, string>(
          "remove",
          labels
        );
        const request = this.buildRequest<
          services.LabelOperation,
          services.IMutateLabelsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "LabelService.mutateLabels",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateLabels(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/MediaFileService
   */
  public get mediaFiles() {
    const service = this.loadService<services.MediaFileService>(
      "MediaFileServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateMediaFilesRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.MediaFile in full detail
       * @warning Don't use get in production!
       * @returns resources.MediaFile
       */
      get: async (resourceName: string): Promise<resources.MediaFile> => {
        const request = new services.GetMediaFileRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getMediaFile(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IMediaFile
       * @returns services.MutateMediaFilesResponse
       */
      create: async (
        mediaFiles: (resources.IMediaFile | resources.MediaFile)[],
        options?: MutateOptions
      ): Promise<services.MutateMediaFilesResponse> => {
        const ops = this.buildOperations<
          services.MediaFileOperation,
          resources.IMediaFile
        >("create", mediaFiles);
        const request = this.buildRequest<
          services.MediaFileOperation,
          services.IMutateMediaFilesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "MediaFileService.mutateMediaFiles",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateMediaFiles(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/RemarketingActionService
   */
  public get remarketingActions() {
    const service = this.loadService<services.RemarketingActionService>(
      "RemarketingActionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateRemarketingActionsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.RemarketingAction in full detail
       * @warning Don't use get in production!
       * @returns resources.RemarketingAction
       */
      get: async (
        resourceName: string
      ): Promise<resources.RemarketingAction> => {
        const request = new services.GetRemarketingActionRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getRemarketingAction(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IRemarketingAction
       * @returns services.MutateRemarketingActionsResponse
       */
      create: async (
        remarketingActions: (
          | resources.IRemarketingAction
          | resources.RemarketingAction
        )[],
        options?: MutateOptions
      ): Promise<services.MutateRemarketingActionsResponse> => {
        const ops = this.buildOperations<
          services.RemarketingActionOperation,
          resources.IRemarketingAction
        >("create", remarketingActions);
        const request = this.buildRequest<
          services.RemarketingActionOperation,
          services.IMutateRemarketingActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "RemarketingActionService.mutateRemarketingActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateRemarketingActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IRemarketingAction
       * @returns services.MutateRemarketingActionsResponse
       */
      update: async (
        remarketingActions: (
          | resources.IRemarketingAction
          | resources.RemarketingAction
        )[],
        options?: MutateOptions
      ): Promise<services.MutateRemarketingActionsResponse> => {
        const ops = this.buildOperations<
          services.RemarketingActionOperation,
          resources.IRemarketingAction
        >(
          "update",
          remarketingActions,
          // @ts-expect-error Static class type here is fine
          resources.RemarketingAction
        );
        const request = this.buildRequest<
          services.RemarketingActionOperation,
          services.IMutateRemarketingActionsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "RemarketingActionService.mutateRemarketingActions",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateRemarketingActions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/SharedCriterionService
   */
  public get sharedCriteria() {
    const service = this.loadService<services.SharedCriterionService>(
      "SharedCriterionServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateSharedCriteriaRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.SharedCriterion in full detail
       * @warning Don't use get in production!
       * @returns resources.SharedCriterion
       */
      get: async (resourceName: string): Promise<resources.SharedCriterion> => {
        const request = new services.GetSharedCriterionRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getSharedCriterion(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ISharedCriterion
       * @returns services.MutateSharedCriteriaResponse
       */
      create: async (
        sharedCriteria: (
          | resources.ISharedCriterion
          | resources.SharedCriterion
        )[],
        options?: MutateOptions
      ): Promise<services.MutateSharedCriteriaResponse> => {
        const ops = this.buildOperations<
          services.SharedCriterionOperation,
          resources.ISharedCriterion
        >("create", sharedCriteria);
        const request = this.buildRequest<
          services.SharedCriterionOperation,
          services.IMutateSharedCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedCriterionService.mutateSharedCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateSharedCriteriaResponse
       */
      remove: async (
        sharedCriteria: string[],
        options?: MutateOptions
      ): Promise<services.MutateSharedCriteriaResponse> => {
        const ops = this.buildOperations<
          services.SharedCriterionOperation,
          string
        >("remove", sharedCriteria);
        const request = this.buildRequest<
          services.SharedCriterionOperation,
          services.IMutateSharedCriteriaRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedCriterionService.mutateSharedCriteria",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedCriteria(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/SharedSetService
   */
  public get sharedSets() {
    const service = this.loadService<services.SharedSetService>(
      "SharedSetServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateSharedSetsRequest,
        "partial_failure" | "validate_only" | "response_content_type"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.SharedSet in full detail
       * @warning Don't use get in production!
       * @returns resources.SharedSet
       */
      get: async (resourceName: string): Promise<resources.SharedSet> => {
        const request = new services.GetSharedSetRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getSharedSet(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ISharedSet
       * @returns services.MutateSharedSetsResponse
       */
      create: async (
        sharedSets: (resources.ISharedSet | resources.SharedSet)[],
        options?: MutateOptions
      ): Promise<services.MutateSharedSetsResponse> => {
        const ops = this.buildOperations<
          services.SharedSetOperation,
          resources.ISharedSet
        >("create", sharedSets);
        const request = this.buildRequest<
          services.SharedSetOperation,
          services.IMutateSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedSetService.mutateSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ISharedSet
       * @returns services.MutateSharedSetsResponse
       */
      update: async (
        sharedSets: (resources.ISharedSet | resources.SharedSet)[],
        options?: MutateOptions
      ): Promise<services.MutateSharedSetsResponse> => {
        const ops = this.buildOperations<
          services.SharedSetOperation,
          resources.ISharedSet
        >(
          "update",
          sharedSets,
          // @ts-expect-error Static class type here is fine
          resources.SharedSet
        );
        const request = this.buildRequest<
          services.SharedSetOperation,
          services.IMutateSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedSetService.mutateSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateSharedSetsResponse
       */
      remove: async (
        sharedSets: string[],
        options?: MutateOptions
      ): Promise<services.MutateSharedSetsResponse> => {
        const ops = this.buildOperations<services.SharedSetOperation, string>(
          "remove",
          sharedSets
        );
        const request = this.buildRequest<
          services.SharedSetOperation,
          services.IMutateSharedSetsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "SharedSetService.mutateSharedSets",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateSharedSets(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/UserListService
   */
  public get userLists() {
    const service = this.loadService<services.UserListService>(
      "UserListServiceClient"
    );
    type MutateOptions = Partial<
      Pick<
        services.IMutateUserListsRequest,
        "partial_failure" | "validate_only"
      >
    >;
    return {
      /**
       * @description Retrieve a resources.UserList in full detail
       * @warning Don't use get in production!
       * @returns resources.UserList
       */
      get: async (resourceName: string): Promise<resources.UserList> => {
        const request = new services.GetUserListRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getUserList(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IUserList
       * @returns services.MutateUserListsResponse
       */
      create: async (
        userLists: (resources.IUserList | resources.UserList)[],
        options?: MutateOptions
      ): Promise<services.MutateUserListsResponse> => {
        const ops = this.buildOperations<
          services.UserListOperation,
          resources.IUserList
        >("create", userLists);
        const request = this.buildRequest<
          services.UserListOperation,
          services.IMutateUserListsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "UserListService.mutateUserLists",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateUserLists(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.IUserList
       * @returns services.MutateUserListsResponse
       */
      update: async (
        userLists: (resources.IUserList | resources.UserList)[],
        options?: MutateOptions
      ): Promise<services.MutateUserListsResponse> => {
        const ops = this.buildOperations<
          services.UserListOperation,
          resources.IUserList
        >(
          "update",
          userLists,
          // @ts-expect-error Static class type here is fine
          resources.UserList
        );
        const request = this.buildRequest<
          services.UserListOperation,
          services.IMutateUserListsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "UserListService.mutateUserLists",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateUserLists(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateUserListsResponse
       */
      remove: async (
        userLists: string[],
        options?: MutateOptions
      ): Promise<services.MutateUserListsResponse> => {
        const ops = this.buildOperations<services.UserListOperation, string>(
          "remove",
          userLists
        );
        const request = this.buildRequest<
          services.UserListOperation,
          services.IMutateUserListsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "UserListService.mutateUserLists",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateUserLists(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response: this.decodePartialFailureError(response),
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return this.decodePartialFailureError(response);
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/BillingSetupService
   */
  public get billingSetups() {
    const service = this.loadService<services.BillingSetupService>(
      "BillingSetupServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @description Retrieve a resources.BillingSetup in full detail
       * @warning Don't use get in production!
       * @returns resources.BillingSetup
       */
      get: async (resourceName: string): Promise<resources.BillingSetup> => {
        const request = new services.GetBillingSetupRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getBillingSetup(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.IBillingSetup
       * @returns services.MutateBillingSetupResponse
       */
      create: async (
        billingSetups: (resources.IBillingSetup | resources.BillingSetup)[],
        options?: MutateOptions
      ): Promise<services.MutateBillingSetupResponse> => {
        const ops = this.buildOperations<
          services.BillingSetupOperation,
          resources.IBillingSetup
        >("create", billingSetups);
        const request = this.buildRequest<
          services.BillingSetupOperation,
          services.IMutateBillingSetupRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BillingSetupService.mutateBillingSetup",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBillingSetup(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateBillingSetupResponse
       */
      remove: async (
        billingSetups: string[],
        options?: MutateOptions
      ): Promise<services.MutateBillingSetupResponse> => {
        const ops = this.buildOperations<
          services.BillingSetupOperation,
          string
        >("remove", billingSetups);
        const request = this.buildRequest<
          services.BillingSetupOperation,
          services.IMutateBillingSetupRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "BillingSetupService.mutateBillingSetup",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateBillingSetup(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignAudienceViewService
   */
  public get campaignAudienceViews() {
    const service = this.loadService<services.CampaignAudienceViewService>(
      "CampaignAudienceViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.CampaignAudienceView in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignAudienceView
       */
      get: async (
        resourceName: string
      ): Promise<resources.CampaignAudienceView> => {
        const request = new services.GetCampaignAudienceViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignAudienceView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CampaignCriterionSimulationService
   */
  public get campaignCriterionSimulations() {
    const service = this.loadService<services.CampaignCriterionSimulationService>(
      "CampaignCriterionSimulationServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.CampaignCriterionSimulation in full detail
       * @warning Don't use get in production!
       * @returns resources.CampaignCriterionSimulation
       */
      get: async (
        resourceName: string
      ): Promise<resources.CampaignCriterionSimulation> => {
        const request = new services.GetCampaignCriterionSimulationRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCampaignCriterionSimulation(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CarrierConstantService
   */
  public get carrierConstants() {
    const service = this.loadService<services.CarrierConstantService>(
      "CarrierConstantServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.CarrierConstant in full detail
       * @warning Don't use get in production!
       * @returns resources.CarrierConstant
       */
      get: async (resourceName: string): Promise<resources.CarrierConstant> => {
        const request = new services.GetCarrierConstantRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCarrierConstant(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ChangeStatusService
   */
  public get changeStatuses() {
    const service = this.loadService<services.ChangeStatusService>(
      "ChangeStatusServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.ChangeStatus in full detail
       * @warning Don't use get in production!
       * @returns resources.ChangeStatus
       */
      get: async (resourceName: string): Promise<resources.ChangeStatus> => {
        const request = new services.GetChangeStatusRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getChangeStatus(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ClickViewService
   */
  public get clickViews() {
    const service = this.loadService<services.ClickViewService>(
      "ClickViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.ClickView in full detail
       * @warning Don't use get in production!
       * @returns resources.ClickView
       */
      get: async (resourceName: string): Promise<resources.ClickView> => {
        const request = new services.GetClickViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getClickView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CombinedAudienceService
   */
  public get combinedAudiences() {
    const service = this.loadService<services.CombinedAudienceService>(
      "CombinedAudienceServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.CombinedAudience in full detail
       * @warning Don't use get in production!
       * @returns resources.CombinedAudience
       */
      get: async (
        resourceName: string
      ): Promise<resources.CombinedAudience> => {
        const request = new services.GetCombinedAudienceRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCombinedAudience(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ConversionAdjustmentUploadService
   */
  public get conversionAdjustmentUploads() {
    const service = this.loadService<services.ConversionAdjustmentUploadService>(
      "ConversionAdjustmentUploadServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ConversionAdjustmentUploadService#uploadconversionadjustments
       */
      uploadConversionAdjustments: async (
        request: services.UploadConversionAdjustmentsRequest
      ): Promise<services.UploadConversionAdjustmentsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.uploadConversionAdjustments(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ConversionUploadService
   */
  public get conversionUploads() {
    const service = this.loadService<services.ConversionUploadService>(
      "ConversionUploadServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ConversionUploadService#uploadclickconversions
       */
      uploadClickConversions: async (
        request: services.UploadClickConversionsRequest
      ): Promise<services.UploadClickConversionsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.uploadClickConversions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ConversionUploadService#uploadcallconversions
       */
      uploadCallConversions: async (
        request: services.UploadCallConversionsRequest
      ): Promise<services.UploadCallConversionsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.uploadCallConversions(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CurrencyConstantService
   */
  public get currencyConstants() {
    const service = this.loadService<services.CurrencyConstantService>(
      "CurrencyConstantServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.CurrencyConstant in full detail
       * @warning Don't use get in production!
       * @returns resources.CurrencyConstant
       */
      get: async (
        resourceName: string
      ): Promise<resources.CurrencyConstant> => {
        const request = new services.GetCurrencyConstantRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCurrencyConstant(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomAudienceService
   */
  public get customAudiences() {
    const service = this.loadService<services.CustomAudienceService>(
      "CustomAudienceServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateCustomAudiencesRequest, "validate_only">
    >;
    return {
      /**
       * @description Retrieve a resources.CustomAudience in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomAudience
       */
      get: async (resourceName: string): Promise<resources.CustomAudience> => {
        const request = new services.GetCustomAudienceRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomAudience(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICustomAudience
       * @returns services.MutateCustomAudiencesResponse
       */
      create: async (
        customAudiences: (
          | resources.ICustomAudience
          | resources.CustomAudience
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomAudiencesResponse> => {
        const ops = this.buildOperations<
          services.CustomAudienceOperation,
          resources.ICustomAudience
        >("create", customAudiences);
        const request = this.buildRequest<
          services.CustomAudienceOperation,
          services.IMutateCustomAudiencesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomAudienceService.mutateCustomAudiences",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomAudiences(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomAudience
       * @returns services.MutateCustomAudiencesResponse
       */
      update: async (
        customAudiences: (
          | resources.ICustomAudience
          | resources.CustomAudience
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomAudiencesResponse> => {
        const ops = this.buildOperations<
          services.CustomAudienceOperation,
          resources.ICustomAudience
        >(
          "update",
          customAudiences,
          // @ts-expect-error Static class type here is fine
          resources.CustomAudience
        );
        const request = this.buildRequest<
          services.CustomAudienceOperation,
          services.IMutateCustomAudiencesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomAudienceService.mutateCustomAudiences",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomAudiences(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomAudiencesResponse
       */
      remove: async (
        customAudiences: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomAudiencesResponse> => {
        const ops = this.buildOperations<
          services.CustomAudienceOperation,
          string
        >("remove", customAudiences);
        const request = this.buildRequest<
          services.CustomAudienceOperation,
          services.IMutateCustomAudiencesRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomAudienceService.mutateCustomAudiences",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomAudiences(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomInterestService
   */
  public get customInterests() {
    const service = this.loadService<services.CustomInterestService>(
      "CustomInterestServiceClient"
    );
    type MutateOptions = Partial<
      Pick<services.IMutateCustomInterestsRequest, "validate_only">
    >;
    return {
      /**
       * @description Retrieve a resources.CustomInterest in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomInterest
       */
      get: async (resourceName: string): Promise<resources.CustomInterest> => {
        const request = new services.GetCustomInterestRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomInterest(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICustomInterest
       * @returns services.MutateCustomInterestsResponse
       */
      create: async (
        customInterests: (
          | resources.ICustomInterest
          | resources.CustomInterest
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomInterestsResponse> => {
        const ops = this.buildOperations<
          services.CustomInterestOperation,
          resources.ICustomInterest
        >("create", customInterests);
        const request = this.buildRequest<
          services.CustomInterestOperation,
          services.IMutateCustomInterestsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomInterestService.mutateCustomInterests",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomInterests(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomInterest
       * @returns services.MutateCustomInterestsResponse
       */
      update: async (
        customInterests: (
          | resources.ICustomInterest
          | resources.CustomInterest
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomInterestsResponse> => {
        const ops = this.buildOperations<
          services.CustomInterestOperation,
          resources.ICustomInterest
        >(
          "update",
          customInterests,
          // @ts-expect-error Static class type here is fine
          resources.CustomInterest
        );
        const request = this.buildRequest<
          services.CustomInterestOperation,
          services.IMutateCustomInterestsRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomInterestService.mutateCustomInterests",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomInterests(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerClientLinkService
   */
  public get customerClientLinks() {
    const service = this.loadService<services.CustomerClientLinkService>(
      "CustomerClientLinkServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @description Retrieve a resources.CustomerClientLink in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomerClientLink
       */
      get: async (
        resourceName: string
      ): Promise<resources.CustomerClientLink> => {
        const request = new services.GetCustomerClientLinkRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomerClientLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICustomerClientLink
       * @returns services.MutateCustomerClientLinkResponse
       */
      create: async (
        customerClientLinks: (
          | resources.ICustomerClientLink
          | resources.CustomerClientLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerClientLinkResponse> => {
        const ops = this.buildOperations<
          services.CustomerClientLinkOperation,
          resources.ICustomerClientLink
        >("create", customerClientLinks);
        const request = this.buildRequest<
          services.CustomerClientLinkOperation,
          services.IMutateCustomerClientLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerClientLinkService.mutateCustomerClientLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerClientLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description update resources of type resources.ICustomerClientLink
       * @returns services.MutateCustomerClientLinkResponse
       */
      update: async (
        customerClientLinks: (
          | resources.ICustomerClientLink
          | resources.CustomerClientLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerClientLinkResponse> => {
        const ops = this.buildOperations<
          services.CustomerClientLinkOperation,
          resources.ICustomerClientLink
        >(
          "update",
          customerClientLinks,
          // @ts-expect-error Static class type here is fine
          resources.CustomerClientLink
        );
        const request = this.buildRequest<
          services.CustomerClientLinkOperation,
          services.IMutateCustomerClientLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerClientLinkService.mutateCustomerClientLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerClientLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerClientService
   */
  public get customerClients() {
    const service = this.loadService<services.CustomerClientService>(
      "CustomerClientServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.CustomerClient in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomerClient
       */
      get: async (resourceName: string): Promise<resources.CustomerClient> => {
        const request = new services.GetCustomerClientRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomerClient(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerManagerLinkService
   */
  public get customerManagerLinks() {
    const service = this.loadService<services.CustomerManagerLinkService>(
      "CustomerManagerLinkServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @description Retrieve a resources.CustomerManagerLink in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomerManagerLink
       */
      get: async (
        resourceName: string
      ): Promise<resources.CustomerManagerLink> => {
        const request = new services.GetCustomerManagerLinkRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomerManagerLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description update resources of type resources.ICustomerManagerLink
       * @returns services.MutateCustomerManagerLinkResponse
       */
      update: async (
        customerManagerLinks: (
          | resources.ICustomerManagerLink
          | resources.CustomerManagerLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerManagerLinkResponse> => {
        const ops = this.buildOperations<
          services.CustomerManagerLinkOperation,
          resources.ICustomerManagerLink
        >(
          "update",
          customerManagerLinks,
          // @ts-expect-error Static class type here is fine
          resources.CustomerManagerLink
        );
        const request = this.buildRequest<
          services.CustomerManagerLinkOperation,
          services.IMutateCustomerManagerLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerManagerLinkService.mutateCustomerManagerLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerManagerLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerManagerLinkService#movemanagerlink
       */
      moveManagerLink: async (
        request: services.MoveManagerLinkRequest
      ): Promise<services.MoveManagerLinkResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.moveManagerLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerUserAccessInvitationService
   */
  public get customerUserAccessInvitations() {
    const service = this.loadService<services.CustomerUserAccessInvitationService>(
      "CustomerUserAccessInvitationServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @description Retrieve a resources.CustomerUserAccessInvitation in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomerUserAccessInvitation
       */
      get: async (
        resourceName: string
      ): Promise<resources.CustomerUserAccessInvitation> => {
        const request = new services.GetCustomerUserAccessInvitationRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomerUserAccessInvitation(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description create resources of type resources.ICustomerUserAccessInvitation
       * @returns services.MutateCustomerUserAccessInvitationResponse
       */
      create: async (
        customerUserAccessInvitations: (
          | resources.ICustomerUserAccessInvitation
          | resources.CustomerUserAccessInvitation
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerUserAccessInvitationResponse> => {
        const ops = this.buildOperations<
          services.CustomerUserAccessInvitationOperation,
          resources.ICustomerUserAccessInvitation
        >("create", customerUserAccessInvitations);
        const request = this.buildRequest<
          services.CustomerUserAccessInvitationOperation,
          services.IMutateCustomerUserAccessInvitationRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerUserAccessInvitationService.mutateCustomerUserAccessInvitation",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerUserAccessInvitation(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerUserAccessInvitationResponse
       */
      remove: async (
        customerUserAccessInvitations: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerUserAccessInvitationResponse> => {
        const ops = this.buildOperations<
          services.CustomerUserAccessInvitationOperation,
          string
        >("remove", customerUserAccessInvitations);
        const request = this.buildRequest<
          services.CustomerUserAccessInvitationOperation,
          services.IMutateCustomerUserAccessInvitationRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method:
            "CustomerUserAccessInvitationService.mutateCustomerUserAccessInvitation",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerUserAccessInvitation(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/CustomerUserAccessService
   */
  public get customerUserAccesses() {
    const service = this.loadService<services.CustomerUserAccessService>(
      "CustomerUserAccessServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @description Retrieve a resources.CustomerUserAccess in full detail
       * @warning Don't use get in production!
       * @returns resources.CustomerUserAccess
       */
      get: async (
        resourceName: string
      ): Promise<resources.CustomerUserAccess> => {
        const request = new services.GetCustomerUserAccessRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getCustomerUserAccess(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description update resources of type resources.ICustomerUserAccess
       * @returns services.MutateCustomerUserAccessResponse
       */
      update: async (
        customerUserAccesses: (
          | resources.ICustomerUserAccess
          | resources.CustomerUserAccess
        )[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerUserAccessResponse> => {
        const ops = this.buildOperations<
          services.CustomerUserAccessOperation,
          resources.ICustomerUserAccess
        >(
          "update",
          customerUserAccesses,
          // @ts-expect-error Static class type here is fine
          resources.CustomerUserAccess
        );
        const request = this.buildRequest<
          services.CustomerUserAccessOperation,
          services.IMutateCustomerUserAccessRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerUserAccessService.mutateCustomerUserAccess",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerUserAccess(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateCustomerUserAccessResponse
       */
      remove: async (
        customerUserAccesses: string[],
        options?: MutateOptions
      ): Promise<services.MutateCustomerUserAccessResponse> => {
        const ops = this.buildOperations<
          services.CustomerUserAccessOperation,
          string
        >("remove", customerUserAccesses);
        const request = this.buildRequest<
          services.CustomerUserAccessOperation,
          services.IMutateCustomerUserAccessRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "CustomerUserAccessService.mutateCustomerUserAccess",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateCustomerUserAccess(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/DetailPlacementViewService
   */
  public get detailPlacementViews() {
    const service = this.loadService<services.DetailPlacementViewService>(
      "DetailPlacementViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.DetailPlacementView in full detail
       * @warning Don't use get in production!
       * @returns resources.DetailPlacementView
       */
      get: async (
        resourceName: string
      ): Promise<resources.DetailPlacementView> => {
        const request = new services.GetDetailPlacementViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getDetailPlacementView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/DisplayKeywordViewService
   */
  public get displayKeywordViews() {
    const service = this.loadService<services.DisplayKeywordViewService>(
      "DisplayKeywordViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.DisplayKeywordView in full detail
       * @warning Don't use get in production!
       * @returns resources.DisplayKeywordView
       */
      get: async (
        resourceName: string
      ): Promise<resources.DisplayKeywordView> => {
        const request = new services.GetDisplayKeywordViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getDisplayKeywordView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/DistanceViewService
   */
  public get distanceViews() {
    const service = this.loadService<services.DistanceViewService>(
      "DistanceViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.DistanceView in full detail
       * @warning Don't use get in production!
       * @returns resources.DistanceView
       */
      get: async (resourceName: string): Promise<resources.DistanceView> => {
        const request = new services.GetDistanceViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getDistanceView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/DomainCategoryService
   */
  public get domainCategories() {
    const service = this.loadService<services.DomainCategoryService>(
      "DomainCategoryServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.DomainCategory in full detail
       * @warning Don't use get in production!
       * @returns resources.DomainCategory
       */
      get: async (resourceName: string): Promise<resources.DomainCategory> => {
        const request = new services.GetDomainCategoryRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getDomainCategory(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/DynamicSearchAdsSearchTermViewService
   */
  public get dynamicSearchAdsSearchTermViews() {
    const service = this.loadService<services.DynamicSearchAdsSearchTermViewService>(
      "DynamicSearchAdsSearchTermViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.DynamicSearchAdsSearchTermView in full detail
       * @warning Don't use get in production!
       * @returns resources.DynamicSearchAdsSearchTermView
       */
      get: async (
        resourceName: string
      ): Promise<resources.DynamicSearchAdsSearchTermView> => {
        const request = new services.GetDynamicSearchAdsSearchTermViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getDynamicSearchAdsSearchTermView(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ExpandedLandingPageViewService
   */
  public get expandedLandingPageViews() {
    const service = this.loadService<services.ExpandedLandingPageViewService>(
      "ExpandedLandingPageViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.ExpandedLandingPageView in full detail
       * @warning Don't use get in production!
       * @returns resources.ExpandedLandingPageView
       */
      get: async (
        resourceName: string
      ): Promise<resources.ExpandedLandingPageView> => {
        const request = new services.GetExpandedLandingPageViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getExpandedLandingPageView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/FeedPlaceholderViewService
   */
  public get feedPlaceholderViews() {
    const service = this.loadService<services.FeedPlaceholderViewService>(
      "FeedPlaceholderViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.FeedPlaceholderView in full detail
       * @warning Don't use get in production!
       * @returns resources.FeedPlaceholderView
       */
      get: async (
        resourceName: string
      ): Promise<resources.FeedPlaceholderView> => {
        const request = new services.GetFeedPlaceholderViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getFeedPlaceholderView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/GenderViewService
   */
  public get genderViews() {
    const service = this.loadService<services.GenderViewService>(
      "GenderViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.GenderView in full detail
       * @warning Don't use get in production!
       * @returns resources.GenderView
       */
      get: async (resourceName: string): Promise<resources.GenderView> => {
        const request = new services.GetGenderViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getGenderView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/GeoTargetConstantService
   */
  public get geoTargetConstants() {
    const service = this.loadService<services.GeoTargetConstantService>(
      "GeoTargetConstantServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.GeoTargetConstant in full detail
       * @warning Don't use get in production!
       * @returns resources.GeoTargetConstant
       */
      get: async (
        resourceName: string
      ): Promise<resources.GeoTargetConstant> => {
        const request = new services.GetGeoTargetConstantRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getGeoTargetConstant(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/GeoTargetConstantService#suggestgeotargetconstants
       */
      suggestGeoTargetConstants: async (
        request: services.SuggestGeoTargetConstantsRequest
      ): Promise<services.SuggestGeoTargetConstantsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.suggestGeoTargetConstants(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/GeographicViewService
   */
  public get geographicViews() {
    const service = this.loadService<services.GeographicViewService>(
      "GeographicViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.GeographicView in full detail
       * @warning Don't use get in production!
       * @returns resources.GeographicView
       */
      get: async (resourceName: string): Promise<resources.GeographicView> => {
        const request = new services.GetGeographicViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getGeographicView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/GroupPlacementViewService
   */
  public get groupPlacementViews() {
    const service = this.loadService<services.GroupPlacementViewService>(
      "GroupPlacementViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.GroupPlacementView in full detail
       * @warning Don't use get in production!
       * @returns resources.GroupPlacementView
       */
      get: async (
        resourceName: string
      ): Promise<resources.GroupPlacementView> => {
        const request = new services.GetGroupPlacementViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getGroupPlacementView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/HotelGroupViewService
   */
  public get hotelGroupViews() {
    const service = this.loadService<services.HotelGroupViewService>(
      "HotelGroupViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.HotelGroupView in full detail
       * @warning Don't use get in production!
       * @returns resources.HotelGroupView
       */
      get: async (resourceName: string): Promise<resources.HotelGroupView> => {
        const request = new services.GetHotelGroupViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getHotelGroupView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/HotelPerformanceViewService
   */
  public get hotelPerformanceViews() {
    const service = this.loadService<services.HotelPerformanceViewService>(
      "HotelPerformanceViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.HotelPerformanceView in full detail
       * @warning Don't use get in production!
       * @returns resources.HotelPerformanceView
       */
      get: async (
        resourceName: string
      ): Promise<resources.HotelPerformanceView> => {
        const request = new services.GetHotelPerformanceViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getHotelPerformanceView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/IncomeRangeViewService
   */
  public get incomeRangeViews() {
    const service = this.loadService<services.IncomeRangeViewService>(
      "IncomeRangeViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.IncomeRangeView in full detail
       * @warning Don't use get in production!
       * @returns resources.IncomeRangeView
       */
      get: async (resourceName: string): Promise<resources.IncomeRangeView> => {
        const request = new services.GetIncomeRangeViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getIncomeRangeView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/InvoiceService
   */
  public get invoices() {
    const service = this.loadService<services.InvoiceService>(
      "InvoiceServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/InvoiceService#listinvoices
       */
      listInvoices: async (
        request: services.ListInvoicesRequest
      ): Promise<services.ListInvoicesResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listInvoices(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanIdeaService
   */
  public get keywordPlanIdeas() {
    const service = this.loadService<services.KeywordPlanIdeaService>(
      "KeywordPlanIdeaServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordPlanIdeaService#generatekeywordideas
       */
      generateKeywordIdeas: async (
        request: services.GenerateKeywordIdeasRequest
      ): Promise<services.GenerateKeywordIdeaResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateKeywordIdeas(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/KeywordViewService
   */
  public get keywordViews() {
    const service = this.loadService<services.KeywordViewService>(
      "KeywordViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.KeywordView in full detail
       * @warning Don't use get in production!
       * @returns resources.KeywordView
       */
      get: async (resourceName: string): Promise<resources.KeywordView> => {
        const request = new services.GetKeywordViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getKeywordView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/LandingPageViewService
   */
  public get landingPageViews() {
    const service = this.loadService<services.LandingPageViewService>(
      "LandingPageViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.LandingPageView in full detail
       * @warning Don't use get in production!
       * @returns resources.LandingPageView
       */
      get: async (resourceName: string): Promise<resources.LandingPageView> => {
        const request = new services.GetLandingPageViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getLandingPageView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/LanguageConstantService
   */
  public get languageConstants() {
    const service = this.loadService<services.LanguageConstantService>(
      "LanguageConstantServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.LanguageConstant in full detail
       * @warning Don't use get in production!
       * @returns resources.LanguageConstant
       */
      get: async (
        resourceName: string
      ): Promise<resources.LanguageConstant> => {
        const request = new services.GetLanguageConstantRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getLanguageConstant(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/LocationViewService
   */
  public get locationViews() {
    const service = this.loadService<services.LocationViewService>(
      "LocationViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.LocationView in full detail
       * @warning Don't use get in production!
       * @returns resources.LocationView
       */
      get: async (resourceName: string): Promise<resources.LocationView> => {
        const request = new services.GetLocationViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getLocationView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ManagedPlacementViewService
   */
  public get managedPlacementViews() {
    const service = this.loadService<services.ManagedPlacementViewService>(
      "ManagedPlacementViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.ManagedPlacementView in full detail
       * @warning Don't use get in production!
       * @returns resources.ManagedPlacementView
       */
      get: async (
        resourceName: string
      ): Promise<resources.ManagedPlacementView> => {
        const request = new services.GetManagedPlacementViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getManagedPlacementView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/MerchantCenterLinkService
   */
  public get merchantCenterLinks() {
    const service = this.loadService<services.MerchantCenterLinkService>(
      "MerchantCenterLinkServiceClient"
    );
    type MutateOptions = never;
    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/MerchantCenterLinkService#listmerchantcenterlinks
       */
      listMerchantCenterLinks: async (
        request: services.ListMerchantCenterLinksRequest
      ): Promise<services.ListMerchantCenterLinksResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listMerchantCenterLinks(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description Retrieve a resources.MerchantCenterLink in full detail
       * @warning Don't use get in production!
       * @returns resources.MerchantCenterLink
       */
      get: async (
        resourceName: string
      ): Promise<resources.MerchantCenterLink> => {
        const request = new services.GetMerchantCenterLinkRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getMerchantCenterLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description update resources of type resources.IMerchantCenterLink
       * @returns services.MutateMerchantCenterLinkResponse
       */
      update: async (
        merchantCenterLinks: (
          | resources.IMerchantCenterLink
          | resources.MerchantCenterLink
        )[],
        options?: MutateOptions
      ): Promise<services.MutateMerchantCenterLinkResponse> => {
        const ops = this.buildOperations<
          services.MerchantCenterLinkOperation,
          resources.IMerchantCenterLink
        >(
          "update",
          merchantCenterLinks,
          // @ts-expect-error Static class type here is fine
          resources.MerchantCenterLink
        );
        const request = this.buildRequest<
          services.MerchantCenterLinkOperation,
          services.IMutateMerchantCenterLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "MerchantCenterLinkService.mutateMerchantCenterLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateMerchantCenterLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },

      /**
       * @description remove resources of type string
       * @returns services.MutateMerchantCenterLinkResponse
       */
      remove: async (
        merchantCenterLinks: string[],
        options?: MutateOptions
      ): Promise<services.MutateMerchantCenterLinkResponse> => {
        const ops = this.buildOperations<
          services.MerchantCenterLinkOperation,
          string
        >("remove", merchantCenterLinks);
        const request = this.buildRequest<
          services.MerchantCenterLinkOperation,
          services.IMutateMerchantCenterLinkRequest,
          MutateOptions
        >(ops, options);
        const baseHookArguments: BaseMutationHookArgs = {
          credentials: this.credentials,
          method: "MerchantCenterLinkService.mutateMerchantCenterLink",
          mutation: request,
          isServiceCall: true,
        };
        if (this.hooks.onMutationStart) {
          const mutationCancellation: HookedCancellation = { cancelled: false };
          await this.hooks.onMutationStart({
            ...baseHookArguments,
            cancel: (res) => {
              mutationCancellation.cancelled = true;
              mutationCancellation.res = res;
            },
            editOptions: (options) => {
              Object.entries(options).forEach(([key, val]) => {
                // @ts-expect-error Index with key type is fine
                request[key] = val;
              });
            },
          });
          if (mutationCancellation.cancelled) {
            return mutationCancellation.res;
          }
        }
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.mutateMerchantCenterLink(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          if (this.hooks.onMutationEnd) {
            const mutationResolution: HookedResolution = { resolved: false };
            await this.hooks.onMutationEnd({
              ...baseHookArguments,
              response,
              resolve: (res) => {
                mutationResolution.resolved = true;
                mutationResolution.res = res;
              },
            });
            if (mutationResolution.resolved) {
              return mutationResolution.res;
            }
          }
          return response;
        } catch (err) {
          const googleAdsError = this.getGoogleAdsError(err);
          if (this.hooks.onMutationError) {
            await this.hooks.onMutationError({
              ...baseHookArguments,
              error: googleAdsError,
            });
          }
          throw googleAdsError;
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/MobileAppCategoryConstantService
   */
  public get mobileAppCategoryConstants() {
    const service = this.loadService<services.MobileAppCategoryConstantService>(
      "MobileAppCategoryConstantServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.MobileAppCategoryConstant in full detail
       * @warning Don't use get in production!
       * @returns resources.MobileAppCategoryConstant
       */
      get: async (
        resourceName: string
      ): Promise<resources.MobileAppCategoryConstant> => {
        const request = new services.GetMobileAppCategoryConstantRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getMobileAppCategoryConstant(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/MobileDeviceConstantService
   */
  public get mobileDeviceConstants() {
    const service = this.loadService<services.MobileDeviceConstantService>(
      "MobileDeviceConstantServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.MobileDeviceConstant in full detail
       * @warning Don't use get in production!
       * @returns resources.MobileDeviceConstant
       */
      get: async (
        resourceName: string
      ): Promise<resources.MobileDeviceConstant> => {
        const request = new services.GetMobileDeviceConstantRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getMobileDeviceConstant(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/OfflineUserDataJobService
   */
  public get offlineUserDataJobs() {
    const service = this.loadService<services.OfflineUserDataJobService>(
      "OfflineUserDataJobServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/OfflineUserDataJobService#createofflineuserdatajob
       */
      createOfflineUserDataJob: async (
        request: services.CreateOfflineUserDataJobRequest
      ): Promise<services.CreateOfflineUserDataJobResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.createOfflineUserDataJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @description Retrieve a resources.OfflineUserDataJob in full detail
       * @warning Don't use get in production!
       * @returns resources.OfflineUserDataJob
       */
      get: async (
        resourceName: string
      ): Promise<resources.OfflineUserDataJob> => {
        const request = new services.GetOfflineUserDataJobRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getOfflineUserDataJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/OfflineUserDataJobService#addofflineuserdatajoboperations
       */
      addOfflineUserDataJobOperations: async (
        request: services.AddOfflineUserDataJobOperationsRequest
      ): Promise<services.AddOfflineUserDataJobOperationsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.addOfflineUserDataJobOperations(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/OfflineUserDataJobService#runofflineuserdatajob
       */
      runOfflineUserDataJob: async (
        request: services.RunOfflineUserDataJobRequest
      ): Promise<longrunning.Operation> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.runOfflineUserDataJob(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/OperatingSystemVersionConstantService
   */
  public get operatingSystemVersionConstants() {
    const service = this.loadService<services.OperatingSystemVersionConstantService>(
      "OperatingSystemVersionConstantServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.OperatingSystemVersionConstant in full detail
       * @warning Don't use get in production!
       * @returns resources.OperatingSystemVersionConstant
       */
      get: async (
        resourceName: string
      ): Promise<resources.OperatingSystemVersionConstant> => {
        const request = new services.GetOperatingSystemVersionConstantRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getOperatingSystemVersionConstant(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/PaidOrganicSearchTermViewService
   */
  public get paidOrganicSearchTermViews() {
    const service = this.loadService<services.PaidOrganicSearchTermViewService>(
      "PaidOrganicSearchTermViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.PaidOrganicSearchTermView in full detail
       * @warning Don't use get in production!
       * @returns resources.PaidOrganicSearchTermView
       */
      get: async (
        resourceName: string
      ): Promise<resources.PaidOrganicSearchTermView> => {
        const request = new services.GetPaidOrganicSearchTermViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getPaidOrganicSearchTermView(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ParentalStatusViewService
   */
  public get parentalStatusViews() {
    const service = this.loadService<services.ParentalStatusViewService>(
      "ParentalStatusViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.ParentalStatusView in full detail
       * @warning Don't use get in production!
       * @returns resources.ParentalStatusView
       */
      get: async (
        resourceName: string
      ): Promise<resources.ParentalStatusView> => {
        const request = new services.GetParentalStatusViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getParentalStatusView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/PaymentsAccountService
   */
  public get paymentsAccounts() {
    const service = this.loadService<services.PaymentsAccountService>(
      "PaymentsAccountServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/PaymentsAccountService#listpaymentsaccounts
       */
      listPaymentsAccounts: async (
        request: services.ListPaymentsAccountsRequest
      ): Promise<services.ListPaymentsAccountsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listPaymentsAccounts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ProductBiddingCategoryConstantService
   */
  public get productBiddingCategoryConstants() {
    const service = this.loadService<services.ProductBiddingCategoryConstantService>(
      "ProductBiddingCategoryConstantServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.ProductBiddingCategoryConstant in full detail
       * @warning Don't use get in production!
       * @returns resources.ProductBiddingCategoryConstant
       */
      get: async (
        resourceName: string
      ): Promise<resources.ProductBiddingCategoryConstant> => {
        const request = new services.GetProductBiddingCategoryConstantRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getProductBiddingCategoryConstant(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ProductGroupViewService
   */
  public get productGroupViews() {
    const service = this.loadService<services.ProductGroupViewService>(
      "ProductGroupViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.ProductGroupView in full detail
       * @warning Don't use get in production!
       * @returns resources.ProductGroupView
       */
      get: async (
        resourceName: string
      ): Promise<resources.ProductGroupView> => {
        const request = new services.GetProductGroupViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getProductGroupView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ReachPlanService
   */
  public get reachPlans() {
    const service = this.loadService<services.ReachPlanService>(
      "ReachPlanServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ReachPlanService#listplannablelocations
       */
      listPlannableLocations: async (
        request: services.ListPlannableLocationsRequest
      ): Promise<services.ListPlannableLocationsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listPlannableLocations(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ReachPlanService#listplannableproducts
       */
      listPlannableProducts: async (
        request: services.ListPlannableProductsRequest
      ): Promise<services.ListPlannableProductsResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.listPlannableProducts(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ReachPlanService#generateproductmixideas
       */
      generateProductMixIdeas: async (
        request: services.GenerateProductMixIdeasRequest
      ): Promise<services.GenerateProductMixIdeasResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateProductMixIdeas(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ReachPlanService#generatereachforecast
       */
      generateReachForecast: async (
        request: services.GenerateReachForecastRequest
      ): Promise<services.GenerateReachForecastResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.generateReachForecast(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/RecommendationService
   */
  public get recommendations() {
    const service = this.loadService<services.RecommendationService>(
      "RecommendationServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.Recommendation in full detail
       * @warning Don't use get in production!
       * @returns resources.Recommendation
       */
      get: async (resourceName: string): Promise<resources.Recommendation> => {
        const request = new services.GetRecommendationRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getRecommendation(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/RecommendationService#applyrecommendation
       */
      applyRecommendation: async (
        request: services.ApplyRecommendationRequest
      ): Promise<services.ApplyRecommendationResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.applyRecommendation(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/RecommendationService#dismissrecommendation
       */
      dismissRecommendation: async (
        request: services.DismissRecommendationRequest
      ): Promise<services.DismissRecommendationResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.dismissRecommendation(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/SearchTermViewService
   */
  public get searchTermViews() {
    const service = this.loadService<services.SearchTermViewService>(
      "SearchTermViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.SearchTermView in full detail
       * @warning Don't use get in production!
       * @returns resources.SearchTermView
       */
      get: async (resourceName: string): Promise<resources.SearchTermView> => {
        const request = new services.GetSearchTermViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getSearchTermView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ShoppingPerformanceViewService
   */
  public get shoppingPerformanceViews() {
    const service = this.loadService<services.ShoppingPerformanceViewService>(
      "ShoppingPerformanceViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.ShoppingPerformanceView in full detail
       * @warning Don't use get in production!
       * @returns resources.ShoppingPerformanceView
       */
      get: async (
        resourceName: string
      ): Promise<resources.ShoppingPerformanceView> => {
        const request = new services.GetShoppingPerformanceViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getShoppingPerformanceView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ThirdPartyAppAnalyticsLinkService
   */
  public get thirdPartyAppAnalyticsLinks() {
    const service = this.loadService<services.ThirdPartyAppAnalyticsLinkService>(
      "ThirdPartyAppAnalyticsLinkServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.ThirdPartyAppAnalyticsLink in full detail
       * @warning Don't use get in production!
       * @returns resources.ThirdPartyAppAnalyticsLink
       */
      get: async (
        resourceName: string
      ): Promise<resources.ThirdPartyAppAnalyticsLink> => {
        const request = new services.GetThirdPartyAppAnalyticsLinkRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getThirdPartyAppAnalyticsLink(
            request,
            {
              // @ts-expect-error This arg doesn't exist in the type definitions
              otherArgs: {
                headers: this.callHeaders,
              },
            }
          );
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },

      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/ThirdPartyAppAnalyticsLinkService#regenerateshareablelinkid
       */
      regenerateShareableLinkId: async (
        request: services.RegenerateShareableLinkIdRequest
      ): Promise<services.RegenerateShareableLinkIdResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.regenerateShareableLinkId(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/TopicConstantService
   */
  public get topicConstants() {
    const service = this.loadService<services.TopicConstantService>(
      "TopicConstantServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.TopicConstant in full detail
       * @warning Don't use get in production!
       * @returns resources.TopicConstant
       */
      get: async (resourceName: string): Promise<resources.TopicConstant> => {
        const request = new services.GetTopicConstantRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getTopicConstant(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/TopicViewService
   */
  public get topicViews() {
    const service = this.loadService<services.TopicViewService>(
      "TopicViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.TopicView in full detail
       * @warning Don't use get in production!
       * @returns resources.TopicView
       */
      get: async (resourceName: string): Promise<resources.TopicView> => {
        const request = new services.GetTopicViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getTopicView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/UserDataService
   */
  public get userData() {
    const service = this.loadService<services.UserDataService>(
      "UserDataServiceClient"
    );

    return {
      /**
       * @link https://developers.google.com/google-ads/api/reference/rpc/v6/UserDataService#uploaduserdata
       */
      uploadUserData: async (
        request: services.UploadUserDataRequest
      ): Promise<services.UploadUserDataResponse> => {
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.uploadUserData(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/UserInterestService
   */
  public get userInterests() {
    const service = this.loadService<services.UserInterestService>(
      "UserInterestServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.UserInterest in full detail
       * @warning Don't use get in production!
       * @returns resources.UserInterest
       */
      get: async (resourceName: string): Promise<resources.UserInterest> => {
        const request = new services.GetUserInterestRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getUserInterest(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/UserLocationViewService
   */
  public get userLocationViews() {
    const service = this.loadService<services.UserLocationViewService>(
      "UserLocationViewServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.UserLocationView in full detail
       * @warning Don't use get in production!
       * @returns resources.UserLocationView
       */
      get: async (
        resourceName: string
      ): Promise<resources.UserLocationView> => {
        const request = new services.GetUserLocationViewRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getUserLocationView(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }

  /**
   * @link https://developers.google.com/google-ads/api/reference/rpc/v6/VideoService
   */
  public get videos() {
    const service = this.loadService<services.VideoService>(
      "VideoServiceClient"
    );

    return {
      /**
       * @description Retrieve a resources.Video in full detail
       * @warning Don't use get in production!
       * @returns resources.Video
       */
      get: async (resourceName: string): Promise<resources.Video> => {
        const request = new services.GetVideoRequest({
          resource_name: resourceName,
        });
        try {
          // @ts-expect-error Response is an array type
          const [response] = await service.getVideo(request, {
            // @ts-expect-error This arg doesn't exist in the type definitions
            otherArgs: {
              headers: this.callHeaders,
            },
          });
          return response;
        } catch (err) {
          throw this.getGoogleAdsError(err);
        }
      },
    };
  }
}
